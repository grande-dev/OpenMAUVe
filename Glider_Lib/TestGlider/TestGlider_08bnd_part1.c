#include "TestGlider_model.h"
#if defined(__cplusplus)
extern "C" {
#endif
extern void TestGlider_eqFunction_877(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_876(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_875(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_874(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_873(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_872(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_871(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_870(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_869(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_867(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_865(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_864(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_863(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_862(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_861(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_860(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_859(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_858(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_857(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_856(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_855(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_854(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_853(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_852(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_850(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_848(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_847(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_846(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_845(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_844(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_843(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_842(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_841(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_840(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_839(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_838(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_837(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_836(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_835(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_834(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_833(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_832(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_831(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_830(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_829(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_828(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_827(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_826(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_825(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_824(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_823(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_822(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_821(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_820(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_819(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_818(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_817(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_816(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_815(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_814(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_813(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_812(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_811(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_810(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_809(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_808(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_807(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_806(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_805(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_804(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_803(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_802(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_801(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_799(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_798(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_797(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_796(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_795(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_794(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_793(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_792(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_791(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_790(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_789(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_788(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_787(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_786(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_785(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_784(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_783(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_782(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_781(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_780(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_779(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_778(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_777(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_776(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_775(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_774(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_773(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_772(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_771(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_770(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_769(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_768(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_767(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_766(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_765(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_764(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_763(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_762(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_761(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_760(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_759(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_758(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_757(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_755(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_753(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_752(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_751(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_750(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_749(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_748(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_747(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_746(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_745(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_744(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_743(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_742(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_741(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_740(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_739(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_738(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_737(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_736(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_735(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_734(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_733(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_732(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_731(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_730(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_729(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_728(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_727(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_726(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_725(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_723(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_720(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_719(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_718(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_717(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_716(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_715(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_714(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_713(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_712(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_711(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_710(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_709(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_708(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_707(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_706(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_705(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_704(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_703(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_700(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_699(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_698(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_697(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_696(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_695(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_694(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_693(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_692(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_691(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_690(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_689(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_688(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_687(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_686(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_685(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_684(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_683(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_682(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_681(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_680(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_679(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_678(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_677(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_676(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_672(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_671(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_670(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_669(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_668(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_667(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_666(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_665(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_664(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_663(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_662(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_661(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_660(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_659(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_658(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_657(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_656(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_655(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_654(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_653(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_652(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_651(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_650(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_649(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_648(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_647(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_646(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_645(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_644(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_643(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_642(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_641(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_640(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_639(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_638(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_636(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_634(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_633(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_632(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_631(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_630(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_629(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_628(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_627(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_626(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_625(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_624(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_623(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_622(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_621(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_620(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_619(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_615(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_614(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_613(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_612(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_611(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_610(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_609(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_608(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_607(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_606(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_605(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_604(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_603(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_602(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_601(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_600(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_599(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_598(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_597(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_596(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_595(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_594(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_593(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_592(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_591(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_590(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_589(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_588(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_587(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_586(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_585(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_584(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_583(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_582(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_581(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_580(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_579(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_578(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_577(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_576(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_575(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_574(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_573(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_572(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_571(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_570(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_569(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_568(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_567(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_566(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_565(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_564(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_563(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_562(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_561(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_560(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_559(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_558(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_557(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_556(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_555(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_554(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_553(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_552(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_551(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_550(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_549(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_548(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_547(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_546(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_545(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_544(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_543(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_542(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_541(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_540(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_539(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_538(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_537(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_536(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_535(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_534(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_533(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_532(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_531(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_530(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_529(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_528(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_527(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_526(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_525(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_524(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_523(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_522(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_521(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_520(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_519(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_518(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_517(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_516(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_515(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_514(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_513(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_512(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_511(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_510(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_509(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_508(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_507(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_506(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_505(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_504(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_503(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_502(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_501(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_500(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_499(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_498(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_497(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_496(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_495(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_494(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_493(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_492(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_491(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_490(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_489(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_488(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_487(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_486(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_485(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_484(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_483(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_482(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_481(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_480(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_479(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_478(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_477(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_476(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_475(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_474(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_473(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_472(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_471(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_468(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_467(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_466(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_465(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_464(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_463(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_462(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_461(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_460(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_459(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_458(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_457(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_456(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_455(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_452(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_451(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_450(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_449(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_448(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_447(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_446(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_445(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_444(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_443(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_442(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_441(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_440(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_439(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_438(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_437(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_436(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_435(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_434(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_433(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_432(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_431(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_430(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_429(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_428(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_427(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_426(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_425(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_424(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_423(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_422(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_421(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_420(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_419(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_418(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_417(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_416(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_415(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_414(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_413(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_412(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_411(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_409(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_408(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_407(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_406(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_405(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_404(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_403(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_402(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_401(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_400(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_399(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_398(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_397(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_396(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_395(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_394(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_392(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_390(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_389(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_388(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_387(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_386(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_385(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_384(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_383(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_382(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_381(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_380(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_379(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_378(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_377(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_376(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_375(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_374(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_373(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_372(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_371(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_370(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_369(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_368(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_367(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_366(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_365(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_364(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_363(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_362(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_361(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_360(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_359(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_358(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_357(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_356(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_355(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_354(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_353(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_352(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_351(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_350(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_349(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_348(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_347(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_346(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_345(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_344(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_343(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_342(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_341(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_337(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_336(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_335(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_334(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_333(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_332(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_331(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_330(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_329(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_328(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_327(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_326(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_325(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_324(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_323(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_322(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_321(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_320(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_319(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_318(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_317(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_316(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_315(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_314(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_313(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_312(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_311(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_310(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_309(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_308(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_307(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_306(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_305(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_304(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_303(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_302(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_301(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_300(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_299(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_298(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_297(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_296(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_295(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_294(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_293(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_292(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_291(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_290(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_289(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_288(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_287(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_286(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_285(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_284(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_283(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_282(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_281(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_280(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_279(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_278(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_277(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_276(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_275(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_274(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_273(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_272(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_271(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_270(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_269(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_268(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_267(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_266(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_265(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_264(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_263(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_262(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_261(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_260(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_259(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_258(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_257(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_256(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_255(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_254(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_253(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_252(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_251(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_250(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_249(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_248(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_247(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_246(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_245(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_244(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_243(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_242(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_241(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_240(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_239(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_238(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_237(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_236(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_235(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_234(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_233(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_232(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_231(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_230(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_229(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_228(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_227(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_226(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_225(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_224(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_223(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_222(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_221(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_220(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_219(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_218(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_217(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_216(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_215(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_214(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_213(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_212(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_211(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_210(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_209(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_208(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_207(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_206(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_205(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_204(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_203(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_175(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_174(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_173(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_202(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_171(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_201(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_200(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_199(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_198(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_197(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_196(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_195(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_194(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_193(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_192(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_191(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_190(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_189(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_188(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_187(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_172(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_176(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_170(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_169(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_168(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_167(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_166(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_165(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_164(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_163(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_162(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_161(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_160(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_159(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_158(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_157(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_156(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_155(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_154(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_153(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_152(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_151(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_150(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_149(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_148(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_147(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_146(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_145(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_144(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_143(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_142(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_141(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_140(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_139(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_138(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_137(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_136(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_135(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_134(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_133(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_132(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_131(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_130(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_129(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_128(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_127(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_126(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_125(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_124(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_123(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_122(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_121(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_120(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_119(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_118(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_117(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_116(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_115(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_114(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_113(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_112(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_111(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_110(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_109(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_108(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_107(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_106(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_105(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_104(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_103(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_102(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_101(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_100(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_99(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_98(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_97(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_96(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_95(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_94(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_93(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_92(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_91(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_90(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_89(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_88(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_87(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_86(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_85(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_84(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_83(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_82(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_81(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_80(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_79(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_78(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_77(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_76(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_75(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_74(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_73(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_72(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_71(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_70(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_69(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_68(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_67(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_66(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_65(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_64(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_63(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_62(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_61(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_60(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_59(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_58(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_57(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_56(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_55(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_54(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_53(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_52(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_51(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_50(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_49(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_48(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_47(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_46(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_45(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_44(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_43(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_42(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_41(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_40(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_39(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_38(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_37(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_36(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_35(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_34(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_33(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_32(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_31(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_30(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_29(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_28(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_27(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_26(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_25(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_24(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_23(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_22(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_21(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_20(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_19(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_18(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_17(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_16(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_15(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_14(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_13(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_12(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_11(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_10(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_9(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_8(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_7(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_6(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_5(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_4(DATA *data, threadData_t *threadData);

extern void TestGlider_eqFunction_2(DATA *data, threadData_t *threadData);


/*
equation index: 7342
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.axisLength >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.axisLength, has value: " + String(genericGlider_mass_explicit.world.axisLength, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7342(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7342};
  modelica_boolean tmp0;
  static const MMC_DEFSTRINGLIT(tmp1,99,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.axisLength, has value: ");
  modelica_string tmp2;
  static int tmp3 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp3)
  {
    tmp0 = GreaterEq(data->simulationInfo->realParameter[508] /* genericGlider_mass_explicit.world.axisLength PARAM */,0.0);
    if(!tmp0)
    {
      tmp2 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[508] /* genericGlider_mass_explicit.world.axisLength PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp1),tmp2);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1082,3,1084,114,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.axisLength >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp3 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7343
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.axisDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.axisDiameter, has value: " + String(genericGlider_mass_explicit.world.axisDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7343(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7343};
  modelica_boolean tmp4;
  static const MMC_DEFSTRINGLIT(tmp5,101,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.axisDiameter, has value: ");
  modelica_string tmp6;
  static int tmp7 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp7)
  {
    tmp4 = GreaterEq(data->simulationInfo->realParameter[507] /* genericGlider_mass_explicit.world.axisDiameter PARAM */,0.0);
    if(!tmp4)
    {
      tmp6 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[507] /* genericGlider_mass_explicit.world.axisDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp5),tmp6);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1085,3,1087,114,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.axisDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp7 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7344
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.x_label.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.x_label.diameter, has value: " + String(genericGlider_mass_explicit.world.x_label.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7344(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7344};
  modelica_boolean tmp8;
  static const MMC_DEFSTRINGLIT(tmp9,105,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.x_label.diameter, has value: ");
  modelica_string tmp10;
  static int tmp11 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp11)
  {
    tmp8 = GreaterEq(data->simulationInfo->realParameter[570] /* genericGlider_mass_explicit.world.x_label.diameter PARAM */,0.0);
    if(!tmp8)
    {
      tmp10 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[570] /* genericGlider_mass_explicit.world.x_label.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp9),tmp10);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",2738,7,2740,25,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.x_label.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp11 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7345
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.y_label.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.y_label.diameter, has value: " + String(genericGlider_mass_explicit.world.y_label.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7345(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7345};
  modelica_boolean tmp12;
  static const MMC_DEFSTRINGLIT(tmp13,105,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.y_label.diameter, has value: ");
  modelica_string tmp14;
  static int tmp15 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp15)
  {
    tmp12 = GreaterEq(data->simulationInfo->realParameter[589] /* genericGlider_mass_explicit.world.y_label.diameter PARAM */,0.0);
    if(!tmp12)
    {
      tmp14 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[589] /* genericGlider_mass_explicit.world.y_label.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp13),tmp14);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",2738,7,2740,25,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.y_label.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp15 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7346
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.z_label.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.z_label.diameter, has value: " + String(genericGlider_mass_explicit.world.z_label.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7346(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7346};
  modelica_boolean tmp16;
  static const MMC_DEFSTRINGLIT(tmp17,105,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.z_label.diameter, has value: ");
  modelica_string tmp18;
  static int tmp19 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp19)
  {
    tmp16 = GreaterEq(data->simulationInfo->realParameter[607] /* genericGlider_mass_explicit.world.z_label.diameter PARAM */,0.0);
    if(!tmp16)
    {
      tmp18 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[607] /* genericGlider_mass_explicit.world.z_label.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp17),tmp18);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",2738,7,2740,25,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.z_label.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp19 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7347
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.gravityArrowDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.gravityArrowDiameter, has value: " + String(genericGlider_mass_explicit.world.gravityArrowDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7347(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7347};
  modelica_boolean tmp20;
  static const MMC_DEFSTRINGLIT(tmp21,109,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.gravityArrowDiameter, has value: ");
  modelica_string tmp22;
  static int tmp23 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp23)
  {
    tmp20 = GreaterEq(data->simulationInfo->realParameter[522] /* genericGlider_mass_explicit.world.gravityArrowDiameter PARAM */,0.0);
    if(!tmp20)
    {
      tmp22 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[522] /* genericGlider_mass_explicit.world.gravityArrowDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp21),tmp22);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1107,3,1111,101,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.gravityArrowDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp23 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7348
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.defaultSpecularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.defaultSpecularCoefficient, has value: " + String(genericGlider_mass_explicit.world.defaultSpecularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7348(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7348};
  modelica_boolean tmp24;
  static const MMC_DEFSTRINGLIT(tmp25,115,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.defaultSpecularCoefficient, has value: ");
  modelica_string tmp26;
  static int tmp27 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp27)
  {
    tmp24 = GreaterEq(data->simulationInfo->realParameter[519] /* genericGlider_mass_explicit.world.defaultSpecularCoefficient PARAM */,0.0);
    if(!tmp24)
    {
      tmp26 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[519] /* genericGlider_mass_explicit.world.defaultSpecularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp25),tmp26);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1175,3,1177,40,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.defaultSpecularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp27 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7349
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7349(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7349};
  modelica_boolean tmp28;
  static const MMC_DEFSTRINGLIT(tmp29,125,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.specularCoefficient, has value: ");
  modelica_string tmp30;
  static int tmp31 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp31)
  {
    tmp28 = GreaterEq(data->simulationInfo->realParameter[151] /* genericGlider_mass_explicit.actuators.body_rolling.specularCoefficient PARAM */,0.0);
    if(!tmp28)
    {
      tmp30 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[151] /* genericGlider_mass_explicit.actuators.body_rolling.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp29),tmp30);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",724,5,729,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp31 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7350
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.width >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.width, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.width, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7350(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7350};
  modelica_boolean tmp32;
  static const MMC_DEFSTRINGLIT(tmp33,121,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.width, has value: ");
  modelica_string tmp34;
  static int tmp35 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp35)
  {
    tmp32 = GreaterEq(data->simulationInfo->realParameter[196] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.width PARAM */,0.0);
    if(!tmp32)
    {
      tmp34 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[196] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.width PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp33),tmp34);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",186,5,190,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_hinge.width >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp35 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7351
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.height >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.height, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.height, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7351(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7351};
  modelica_boolean tmp36;
  static const MMC_DEFSTRINGLIT(tmp37,122,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.height, has value: ");
  modelica_string tmp38;
  static int tmp39 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp39)
  {
    tmp36 = GreaterEq(data->simulationInfo->realParameter[180] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.height PARAM */,0.0);
    if(!tmp36)
    {
      tmp38 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[180] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.height PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp37),tmp38);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",191,5,194,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_hinge.height >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp39 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7352
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7352(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7352};
  modelica_boolean tmp40;
  static const MMC_DEFSTRINGLIT(tmp41,141,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient, has value: ");
  modelica_string tmp42;
  static int tmp43 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp43)
  {
    tmp40 = GreaterEq(data->simulationInfo->realParameter[193] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient PARAM */,0.0);
    if(!tmp40)
    {
      tmp42 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[193] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp41),tmp42);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_hinge.shape.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp43 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7353
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7353(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7353};
  modelica_boolean tmp44;
  static const MMC_DEFSTRINGLIT(tmp45,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient, has value: ");
  modelica_string tmp46;
  static int tmp47 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp47)
  {
    tmp44 = GreaterEq(data->simulationInfo->realParameter[195] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient PARAM */,0.0);
    if(!tmp44)
    {
      tmp46 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[195] /* genericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp45),tmp46);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",207,5,212,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_hinge.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp47 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7354
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.revolute.cylinderLength >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.cylinderLength, has value: " + String(genericGlider_mass_explicit.actuators.revolute.cylinderLength, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7354(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7354};
  modelica_boolean tmp48;
  static const MMC_DEFSTRINGLIT(tmp49,116,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.cylinderLength, has value: ");
  modelica_string tmp50;
  static int tmp51 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp51)
  {
    tmp48 = GreaterEq(data->simulationInfo->realParameter[265] /* genericGlider_mass_explicit.actuators.revolute.cylinderLength PARAM */,0.0);
    if(!tmp48)
    {
      tmp50 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[265] /* genericGlider_mass_explicit.actuators.revolute.cylinderLength PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp49),tmp50);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",229,5,231,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.revolute.cylinderLength >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp51 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7355
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.revolute.cylinderDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.cylinderDiameter, has value: " + String(genericGlider_mass_explicit.actuators.revolute.cylinderDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7355(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7355};
  modelica_boolean tmp52;
  static const MMC_DEFSTRINGLIT(tmp53,118,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.cylinderDiameter, has value: ");
  modelica_string tmp54;
  static int tmp55 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp55)
  {
    tmp52 = GreaterEq(data->simulationInfo->realParameter[264] /* genericGlider_mass_explicit.actuators.revolute.cylinderDiameter PARAM */,0.0);
    if(!tmp52)
    {
      tmp54 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[264] /* genericGlider_mass_explicit.actuators.revolute.cylinderDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp53),tmp54);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",232,5,234,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.revolute.cylinderDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp55 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7356
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7356(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7356};
  modelica_boolean tmp56;
  static const MMC_DEFSTRINGLIT(tmp57,130,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient, has value: ");
  modelica_string tmp58;
  static int tmp59 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp59)
  {
    tmp56 = GreaterEq(data->simulationInfo->realParameter[262] /* genericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient PARAM */,0.0);
    if(!tmp56)
    {
      tmp58 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[262] /* genericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp57),tmp58);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.revolute.cylinder.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp59 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7357
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.revolute.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.revolute.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7357(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7357};
  modelica_boolean tmp60;
  static const MMC_DEFSTRINGLIT(tmp61,121,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.revolute.specularCoefficient, has value: ");
  modelica_string tmp62;
  static int tmp63 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp63)
  {
    tmp60 = GreaterEq(data->simulationInfo->realParameter[274] /* genericGlider_mass_explicit.actuators.revolute.specularCoefficient PARAM */,0.0);
    if(!tmp60)
    {
      tmp62 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[274] /* genericGlider_mass_explicit.actuators.revolute.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp61),tmp62);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",238,5,241,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.revolute.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp63 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7358
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.prismatic.boxWidth >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.boxWidth, has value: " + String(genericGlider_mass_explicit.actuators.prismatic.boxWidth, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7358(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7358};
  modelica_boolean tmp64;
  static const MMC_DEFSTRINGLIT(tmp65,111,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.boxWidth, has value: ");
  modelica_string tmp66;
  static int tmp67 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp67)
  {
    tmp64 = GreaterEq(data->simulationInfo->realParameter[234] /* genericGlider_mass_explicit.actuators.prismatic.boxWidth PARAM */,0.0);
    if(!tmp64)
    {
      tmp66 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[234] /* genericGlider_mass_explicit.actuators.prismatic.boxWidth PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp65),tmp66);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",28,5,30,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.prismatic.boxWidth >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp67 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7359
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.prismatic.boxHeight >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.boxHeight, has value: " + String(genericGlider_mass_explicit.actuators.prismatic.boxHeight, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7359(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7359};
  modelica_boolean tmp68;
  static const MMC_DEFSTRINGLIT(tmp69,112,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.boxHeight, has value: ");
  modelica_string tmp70;
  static int tmp71 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp71)
  {
    tmp68 = GreaterEq(data->simulationInfo->realParameter[233] /* genericGlider_mass_explicit.actuators.prismatic.boxHeight PARAM */,0.0);
    if(!tmp68)
    {
      tmp70 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[233] /* genericGlider_mass_explicit.actuators.prismatic.boxHeight PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp69),tmp70);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",31,5,32,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.prismatic.boxHeight >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp71 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7360
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7360(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7360};
  modelica_boolean tmp72;
  static const MMC_DEFSTRINGLIT(tmp73,126,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient, has value: ");
  modelica_string tmp74;
  static int tmp75 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp75)
  {
    tmp72 = GreaterEq(data->simulationInfo->realParameter[231] /* genericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient PARAM */,0.0);
    if(!tmp72)
    {
      tmp74 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[231] /* genericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp73),tmp74);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.prismatic.box.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp75 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7361
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.prismatic.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.prismatic.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7361(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7361};
  modelica_boolean tmp76;
  static const MMC_DEFSTRINGLIT(tmp77,122,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.prismatic.specularCoefficient, has value: ");
  modelica_string tmp78;
  static int tmp79 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp79)
  {
    tmp76 = GreaterEq(data->simulationInfo->realParameter[246] /* genericGlider_mass_explicit.actuators.prismatic.specularCoefficient PARAM */,0.0);
    if(!tmp76)
    {
      tmp78 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[246] /* genericGlider_mass_explicit.actuators.prismatic.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp77),tmp78);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",36,5,38,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.prismatic.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp79 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7362
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7362(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7362};
  modelica_boolean tmp80;
  static const MMC_DEFSTRINGLIT(tmp81,147,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient, has value: ");
  modelica_string tmp82;
  static int tmp83 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp83)
  {
    tmp80 = GreaterEq(data->simulationInfo->realParameter[213] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient PARAM */,0.0);
    if(!tmp80)
    {
      tmp82 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[213] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp81),tmp82);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.shape.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp83 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7363
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7363(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7363};
  modelica_boolean tmp84;
  static const MMC_DEFSTRINGLIT(tmp85,141,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient, has value: ");
  modelica_string tmp86;
  static int tmp87 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp87)
  {
    tmp84 = GreaterEq(data->simulationInfo->realParameter[214] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient PARAM */,0.0);
    if(!tmp84)
    {
      tmp86 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[214] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp85),tmp86);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",207,5,212,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp87 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7364
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7364(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7364};
  modelica_boolean tmp88;
  static const MMC_DEFSTRINGLIT(tmp89,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient, has value: ");
  modelica_string tmp90;
  static int tmp91 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp91)
  {
    tmp88 = GreaterEq(data->simulationInfo->realParameter[164] /* genericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp88)
    {
      tmp90 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[164] /* genericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp89),tmp90);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.x_arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp91 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7365
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7365(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7365};
  modelica_boolean tmp92;
  static const MMC_DEFSTRINGLIT(tmp93,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient, has value: ");
  modelica_string tmp94;
  static int tmp95 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp95)
  {
    tmp92 = GreaterEq(data->simulationInfo->realParameter[163] /* genericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp92)
    {
      tmp94 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[163] /* genericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp93),tmp94);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.x_arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp95 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7366
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7366(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7366};
  modelica_boolean tmp96;
  static const MMC_DEFSTRINGLIT(tmp97,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient, has value: ");
  modelica_string tmp98;
  static int tmp99 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp99)
  {
    tmp96 = GreaterEq(data->simulationInfo->realParameter[165] /* genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient PARAM */,0.0);
    if(!tmp96)
    {
      tmp98 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[165] /* genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp97),tmp98);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[1].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp99 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7367
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7367(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7367};
  modelica_boolean tmp100;
  static const MMC_DEFSTRINGLIT(tmp101,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient, has value: ");
  modelica_string tmp102;
  static int tmp103 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp103)
  {
    tmp100 = GreaterEq(data->simulationInfo->realParameter[166] /* genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient PARAM */,0.0);
    if(!tmp100)
    {
      tmp102 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[166] /* genericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp101),tmp102);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.x_label.cylinders[2].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp103 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7368
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7368(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7368};
  modelica_boolean tmp104;
  static const MMC_DEFSTRINGLIT(tmp105,131,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient, has value: ");
  modelica_string tmp106;
  static int tmp107 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp107)
  {
    tmp104 = GreaterEq(data->simulationInfo->realParameter[167] /* genericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient PARAM */,0.0);
    if(!tmp104)
    {
      tmp106 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[167] /* genericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp105),tmp106);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",2744,7,2746,28,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.x_label.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp107 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7369
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7369(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7369};
  modelica_boolean tmp108;
  static const MMC_DEFSTRINGLIT(tmp109,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient, has value: ");
  modelica_string tmp110;
  static int tmp111 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp111)
  {
    tmp108 = GreaterEq(data->simulationInfo->realParameter[169] /* genericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp108)
    {
      tmp110 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[169] /* genericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp109),tmp110);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.y_arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp111 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7370
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7370(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7370};
  modelica_boolean tmp112;
  static const MMC_DEFSTRINGLIT(tmp113,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient, has value: ");
  modelica_string tmp114;
  static int tmp115 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp115)
  {
    tmp112 = GreaterEq(data->simulationInfo->realParameter[168] /* genericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp112)
    {
      tmp114 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[168] /* genericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp113),tmp114);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.y_arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp115 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7371
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7371(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7371};
  modelica_boolean tmp116;
  static const MMC_DEFSTRINGLIT(tmp117,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient, has value: ");
  modelica_string tmp118;
  static int tmp119 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp119)
  {
    tmp116 = GreaterEq(data->simulationInfo->realParameter[170] /* genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient PARAM */,0.0);
    if(!tmp116)
    {
      tmp118 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[170] /* genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp117),tmp118);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[1].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp119 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7372
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7372(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7372};
  modelica_boolean tmp120;
  static const MMC_DEFSTRINGLIT(tmp121,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient, has value: ");
  modelica_string tmp122;
  static int tmp123 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp123)
  {
    tmp120 = GreaterEq(data->simulationInfo->realParameter[171] /* genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient PARAM */,0.0);
    if(!tmp120)
    {
      tmp122 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[171] /* genericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp121),tmp122);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.y_label.cylinders[2].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp123 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7373
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7373(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7373};
  modelica_boolean tmp124;
  static const MMC_DEFSTRINGLIT(tmp125,131,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient, has value: ");
  modelica_string tmp126;
  static int tmp127 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp127)
  {
    tmp124 = GreaterEq(data->simulationInfo->realParameter[172] /* genericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient PARAM */,0.0);
    if(!tmp124)
    {
      tmp126 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[172] /* genericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp125),tmp126);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",2744,7,2746,28,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.y_label.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp127 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7374
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7374(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7374};
  modelica_boolean tmp128;
  static const MMC_DEFSTRINGLIT(tmp129,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient, has value: ");
  modelica_string tmp130;
  static int tmp131 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp131)
  {
    tmp128 = GreaterEq(data->simulationInfo->realParameter[174] /* genericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp128)
    {
      tmp130 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[174] /* genericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp129),tmp130);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.z_arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp131 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7375
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7375(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7375};
  modelica_boolean tmp132;
  static const MMC_DEFSTRINGLIT(tmp133,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient, has value: ");
  modelica_string tmp134;
  static int tmp135 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp135)
  {
    tmp132 = GreaterEq(data->simulationInfo->realParameter[173] /* genericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp132)
    {
      tmp134 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[173] /* genericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp133),tmp134);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.z_arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp135 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7376
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7376(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7376};
  modelica_boolean tmp136;
  static const MMC_DEFSTRINGLIT(tmp137,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient, has value: ");
  modelica_string tmp138;
  static int tmp139 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp139)
  {
    tmp136 = GreaterEq(data->simulationInfo->realParameter[175] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient PARAM */,0.0);
    if(!tmp136)
    {
      tmp138 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[175] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp137),tmp138);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[1].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp139 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7377
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7377(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7377};
  modelica_boolean tmp140;
  static const MMC_DEFSTRINGLIT(tmp141,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient, has value: ");
  modelica_string tmp142;
  static int tmp143 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp143)
  {
    tmp140 = GreaterEq(data->simulationInfo->realParameter[176] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient PARAM */,0.0);
    if(!tmp140)
    {
      tmp142 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[176] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp141),tmp142);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[2].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp143 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7378
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7378(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7378};
  modelica_boolean tmp144;
  static const MMC_DEFSTRINGLIT(tmp145,144,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient, has value: ");
  modelica_string tmp146;
  static int tmp147 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp147)
  {
    tmp144 = GreaterEq(data->simulationInfo->realParameter[177] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient PARAM */,0.0);
    if(!tmp144)
    {
      tmp146 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[177] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp145),tmp146);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.z_label.cylinders[3].specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp147 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7379
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7379(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7379};
  modelica_boolean tmp148;
  static const MMC_DEFSTRINGLIT(tmp149,131,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient, has value: ");
  modelica_string tmp150;
  static int tmp151 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp151)
  {
    tmp148 = GreaterEq(data->simulationInfo->realParameter[178] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient PARAM */,0.0);
    if(!tmp148)
    {
      tmp150 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[178] /* genericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp149),tmp150);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",2744,7,2746,28,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.z_label.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp151 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7380
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7380(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7380};
  modelica_boolean tmp152;
  static const MMC_DEFSTRINGLIT(tmp153,123,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient, has value: ");
  modelica_string tmp154;
  static int tmp155 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp155)
  {
    tmp152 = GreaterEq(data->simulationInfo->realParameter[162] /* genericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient PARAM */,0.0);
    if(!tmp152)
    {
      tmp154 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[162] /* genericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp153),tmp154);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",436,5,438,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedFrame.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp155 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7381
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7381(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7381};
  modelica_boolean tmp156;
  static const MMC_DEFSTRINGLIT(tmp157,128,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient, has value: ");
  modelica_string tmp158;
  static int tmp159 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp159)
  {
    tmp156 = GreaterEq(data->simulationInfo->realParameter[277] /* genericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient PARAM */,0.0);
    if(!tmp156)
    {
      tmp158 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[277] /* genericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp157),tmp158);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.shape_green.vis.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp159 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7382
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.shape_green.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_green.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.shape_green.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7382(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7382};
  modelica_boolean tmp160;
  static const MMC_DEFSTRINGLIT(tmp161,124,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_green.specularCoefficient, has value: ");
  modelica_string tmp162;
  static int tmp163 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp163)
  {
    tmp160 = GreaterEq(data->simulationInfo->realParameter[276] /* genericGlider_mass_explicit.actuators.shape_green.specularCoefficient PARAM */,0.0);
    if(!tmp160)
    {
      tmp162 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[276] /* genericGlider_mass_explicit.actuators.shape_green.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp161),tmp162);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",34,5,36,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.shape_green.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp163 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7383
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7383(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7383};
  modelica_boolean tmp164;
  static const MMC_DEFSTRINGLIT(tmp165,141,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient, has value: ");
  modelica_string tmp166;
  static int tmp167 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp167)
  {
    tmp164 = GreaterEq(data->simulationInfo->realParameter[293] /* genericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient PARAM */,0.0);
    if(!tmp164)
    {
      tmp166 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[293] /* genericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp165),tmp166);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.static_translation_VBD.shape.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp167 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7384
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7384(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7384};
  modelica_boolean tmp168;
  static const MMC_DEFSTRINGLIT(tmp169,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient, has value: ");
  modelica_string tmp170;
  static int tmp171 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp171)
  {
    tmp168 = GreaterEq(data->simulationInfo->realParameter[294] /* genericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient PARAM */,0.0);
    if(!tmp168)
    {
      tmp170 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[294] /* genericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp169),tmp170);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",207,5,212,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.static_translation_VBD.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp171 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7385
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7385(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7385};
  modelica_boolean tmp172;
  static const MMC_DEFSTRINGLIT(tmp173,134,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient, has value: ");
  modelica_string tmp174;
  static int tmp175 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp175)
  {
    tmp172 = GreaterEq(data->simulationInfo->realParameter[279] /* genericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient PARAM */,0.0);
    if(!tmp172)
    {
      tmp174 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[279] /* genericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp173),tmp174);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.shape_red_ballast.vis.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp175 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7386
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7386(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7386};
  modelica_boolean tmp176;
  static const MMC_DEFSTRINGLIT(tmp177,130,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient, has value: ");
  modelica_string tmp178;
  static int tmp179 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp179)
  {
    tmp176 = GreaterEq(data->simulationInfo->realParameter[278] /* genericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient PARAM */,0.0);
    if(!tmp176)
    {
      tmp178 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[278] /* genericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp177),tmp178);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",34,5,36,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.shape_red_ballast.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp179 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7387
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7387(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7387};
  modelica_boolean tmp180;
  static const MMC_DEFSTRINGLIT(tmp181,129,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient, has value: ");
  modelica_string tmp182;
  static int tmp183 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp183)
  {
    tmp180 = GreaterEq(data->simulationInfo->realParameter[98] /* genericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient PARAM */,0.0);
    if(!tmp180)
    {
      tmp182 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[98] /* genericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp181),tmp182);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",95,3,100,25,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp183 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7388
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7388(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7388};
  modelica_boolean tmp184;
  static const MMC_DEFSTRINGLIT(tmp185,138,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient, has value: ");
  modelica_string tmp186;
  static int tmp187 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp187)
  {
    tmp184 = GreaterEq(data->simulationInfo->realParameter[373] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp184)
    {
      tmp186 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[373] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp185),tmp186);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.arrow.arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp187 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7389
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7389(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7389};
  modelica_boolean tmp188;
  static const MMC_DEFSTRINGLIT(tmp189,138,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient, has value: ");
  modelica_string tmp190;
  static int tmp191 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp191)
  {
    tmp188 = GreaterEq(data->simulationInfo->realParameter[371] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp188)
    {
      tmp190 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[371] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp189),tmp190);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.arrow.arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp191 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7390
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7390(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7390};
  modelica_boolean tmp192;
  static const MMC_DEFSTRINGLIT(tmp193,128,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient, has value: ");
  modelica_string tmp194;
  static int tmp195 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp195)
  {
    tmp192 = GreaterEq(data->simulationInfo->realParameter[376] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient PARAM */,0.0);
    if(!tmp192)
    {
      tmp194 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[376] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp193),tmp194);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1839,7,1841,127,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.arrow.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp195 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7391
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.specularCoefficient, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7391(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7391};
  modelica_boolean tmp196;
  static const MMC_DEFSTRINGLIT(tmp197,122,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.specularCoefficient, has value: ");
  modelica_string tmp198;
  static int tmp199 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp199)
  {
    tmp196 = GreaterEq(data->simulationInfo->realParameter[384] /* genericGlider_mass_explicit.buoyancyForce.force.specularCoefficient PARAM */,0.0);
    if(!tmp196)
    {
      tmp198 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[384] /* genericGlider_mass_explicit.buoyancyForce.force.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp197),tmp198);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",31,5,33,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp199 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7392
type: ALGORITHM

  assert(genericGlider_mass_explicit.shape_hull.vis.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.shape_hull.vis.specularCoefficient, has value: " + String(genericGlider_mass_explicit.shape_hull.vis.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7392(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7392};
  modelica_boolean tmp200;
  static const MMC_DEFSTRINGLIT(tmp201,117,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.shape_hull.vis.specularCoefficient, has value: ");
  modelica_string tmp202;
  static int tmp203 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp203)
  {
    tmp200 = GreaterEq(data->simulationInfo->realParameter[500] /* genericGlider_mass_explicit.shape_hull.vis.specularCoefficient PARAM */,0.0);
    if(!tmp200)
    {
      tmp202 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[500] /* genericGlider_mass_explicit.shape_hull.vis.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp201),tmp202);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.shape_hull.vis.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp203 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7393
type: ALGORITHM

  assert(genericGlider_mass_explicit.shape_hull.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.shape_hull.specularCoefficient, has value: " + String(genericGlider_mass_explicit.shape_hull.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7393(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7393};
  modelica_boolean tmp204;
  static const MMC_DEFSTRINGLIT(tmp205,113,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.shape_hull.specularCoefficient, has value: ");
  modelica_string tmp206;
  static int tmp207 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp207)
  {
    tmp204 = GreaterEq(data->simulationInfo->realParameter[499] /* genericGlider_mass_explicit.shape_hull.specularCoefficient PARAM */,0.0);
    if(!tmp204)
    {
      tmp206 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[499] /* genericGlider_mass_explicit.shape_hull.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp205),tmp206);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",34,5,36,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.shape_hull.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp207 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7394
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hull.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7394(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7394};
  modelica_boolean tmp208;
  static const MMC_DEFSTRINGLIT(tmp209,107,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.specularCoefficient, has value: ");
  modelica_string tmp210;
  static int tmp211 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp211)
  {
    tmp208 = GreaterEq(data->simulationInfo->realParameter[431] /* genericGlider_mass_explicit.hull.specularCoefficient PARAM */,0.0);
    if(!tmp208)
    {
      tmp210 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[431] /* genericGlider_mass_explicit.hull.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp209),tmp210);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",724,5,729,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp211 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7395
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7395(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7395};
  modelica_boolean tmp212;
  static const MMC_DEFSTRINGLIT(tmp213,147,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient, has value: ");
  modelica_string tmp214;
  static int tmp215 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp215)
  {
    tmp212 = GreaterEq(data->simulationInfo->realParameter[348] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp212)
    {
      tmp214 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[348] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp213),tmp214);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp215 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7396
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7396(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7396};
  modelica_boolean tmp216;
  static const MMC_DEFSTRINGLIT(tmp217,147,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient, has value: ");
  modelica_string tmp218;
  static int tmp219 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp219)
  {
    tmp216 = GreaterEq(data->simulationInfo->realParameter[346] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp216)
    {
      tmp218 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[346] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp217),tmp218);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.arrow.arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp219 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7397
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7397(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7397};
  modelica_boolean tmp220;
  static const MMC_DEFSTRINGLIT(tmp221,137,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient, has value: ");
  modelica_string tmp222;
  static int tmp223 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp223)
  {
    tmp220 = GreaterEq(data->simulationInfo->realParameter[351] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient PARAM */,0.0);
    if(!tmp220)
    {
      tmp222 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[351] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp221),tmp222);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1839,7,1841,127,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.arrow.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp223 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7398
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7398(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7398};
  modelica_boolean tmp224;
  static const MMC_DEFSTRINGLIT(tmp225,131,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient, has value: ");
  modelica_string tmp226;
  static int tmp227 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp227)
  {
    tmp224 = GreaterEq(data->simulationInfo->realParameter[353] /* genericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient PARAM */,0.0);
    if(!tmp224)
    {
      tmp226 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[353] /* genericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp225),tmp226);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",31,5,33,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp227 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7399
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7399(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7399};
  modelica_boolean tmp228;
  static const MMC_DEFSTRINGLIT(tmp229,140,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient, has value: ");
  modelica_string tmp230;
  static int tmp231 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp231)
  {
    tmp228 = GreaterEq(data->simulationInfo->realParameter[343] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient PARAM */,0.0);
    if(!tmp228)
    {
      tmp230 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[343] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp229),tmp230);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",97,5,99,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp231 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7400
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7400(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7400};
  modelica_boolean tmp232;
  static const MMC_DEFSTRINGLIT(tmp233,156,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient, has value: ");
  modelica_string tmp234;
  static int tmp235 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp235)
  {
    tmp232 = GreaterEq(data->simulationInfo->realParameter[337] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp232)
    {
      tmp234 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[337] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp233),tmp234);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp235 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7401
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7401(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7401};
  modelica_boolean tmp236;
  static const MMC_DEFSTRINGLIT(tmp237,156,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient, has value: ");
  modelica_string tmp238;
  static int tmp239 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp239)
  {
    tmp236 = GreaterEq(data->simulationInfo->realParameter[335] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp236)
    {
      tmp238 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[335] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp237),tmp238);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp239 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7402
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7402(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7402};
  modelica_boolean tmp240;
  static const MMC_DEFSTRINGLIT(tmp241,146,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient, has value: ");
  modelica_string tmp242;
  static int tmp243 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp243)
  {
    tmp240 = GreaterEq(data->simulationInfo->realParameter[340] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient PARAM */,0.0);
    if(!tmp240)
    {
      tmp242 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[340] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp241),tmp242);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1839,7,1841,127,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp243 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7403
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7403(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7403};
  modelica_boolean tmp244;
  static const MMC_DEFSTRINGLIT(tmp245,148,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient, has value: ");
  modelica_string tmp246;
  static int tmp247 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp247)
  {
    tmp244 = GreaterEq(data->simulationInfo->realParameter[358] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp244)
    {
      tmp246 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[358] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp245),tmp246);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp247 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7404
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7404(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7404};
  modelica_boolean tmp248;
  static const MMC_DEFSTRINGLIT(tmp249,149,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient, has value: ");
  modelica_string tmp250;
  static int tmp251 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp251)
  {
    tmp248 = GreaterEq(data->simulationInfo->realParameter[355] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient PARAM */,0.0);
    if(!tmp248)
    {
      tmp250 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[355] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp249),tmp250);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead1.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp251 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7405
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7405(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7405};
  modelica_boolean tmp252;
  static const MMC_DEFSTRINGLIT(tmp253,149,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient, has value: ");
  modelica_string tmp254;
  static int tmp255 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp255)
  {
    tmp252 = GreaterEq(data->simulationInfo->realParameter[356] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient PARAM */,0.0);
    if(!tmp252)
    {
      tmp254 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[356] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp253),tmp254);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.arrowHead2.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp255 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7406
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7406(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7406};
  modelica_boolean tmp256;
  static const MMC_DEFSTRINGLIT(tmp257,138,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient, has value: ");
  modelica_string tmp258;
  static int tmp259 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp259)
  {
    tmp256 = GreaterEq(data->simulationInfo->realParameter[361] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient PARAM */,0.0);
    if(!tmp256)
    {
      tmp258 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[361] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp257),tmp258);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1952,7,1954,127,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp259 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7407
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7407(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7407};
  modelica_boolean tmp260;
  static const MMC_DEFSTRINGLIT(tmp261,132,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient, has value: ");
  modelica_string tmp262;
  static int tmp263 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp263)
  {
    tmp260 = GreaterEq(data->simulationInfo->realParameter[363] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient PARAM */,0.0);
    if(!tmp260)
    {
      tmp262 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[363] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp261),tmp262);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",187,5,189,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp263 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7408
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7408(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7408};
  modelica_boolean tmp264;
  static const MMC_DEFSTRINGLIT(tmp265,150,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient, has value: ");
  modelica_string tmp266;
  static int tmp267 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp267)
  {
    tmp264 = GreaterEq(data->simulationInfo->realParameter[463] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp264)
    {
      tmp266 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[463] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp265),tmp266);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp267 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7409
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7409(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7409};
  modelica_boolean tmp268;
  static const MMC_DEFSTRINGLIT(tmp269,150,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient, has value: ");
  modelica_string tmp270;
  static int tmp271 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp271)
  {
    tmp268 = GreaterEq(data->simulationInfo->realParameter[461] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient PARAM */,0.0);
    if(!tmp268)
    {
      tmp270 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[461] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp269),tmp270);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.arrowHead.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp271 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7410
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7410(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7410};
  modelica_boolean tmp272;
  static const MMC_DEFSTRINGLIT(tmp273,140,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient, has value: ");
  modelica_string tmp274;
  static int tmp275 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp275)
  {
    tmp272 = GreaterEq(data->simulationInfo->realParameter[466] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient PARAM */,0.0);
    if(!tmp272)
    {
      tmp274 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[466] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp273),tmp274);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1839,7,1841,127,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp275 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7411
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7411(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7411};
  modelica_boolean tmp276;
  static const MMC_DEFSTRINGLIT(tmp277,134,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient, has value: ");
  modelica_string tmp278;
  static int tmp279 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp279)
  {
    tmp276 = GreaterEq(data->simulationInfo->realParameter[468] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient PARAM */,0.0);
    if(!tmp276)
    {
      tmp278 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[468] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp277),tmp278);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",31,5,33,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp279 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7412
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7412(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7412};
  modelica_boolean tmp280;
  static const MMC_DEFSTRINGLIT(tmp281,151,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient, has value: ");
  modelica_string tmp282;
  static int tmp283 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp283)
  {
    tmp280 = GreaterEq(data->simulationInfo->realParameter[473] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient PARAM */,0.0);
    if(!tmp280)
    {
      tmp282 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[473] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp281),tmp282);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowLine.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp283 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7413
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7413(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7413};
  modelica_boolean tmp284;
  static const MMC_DEFSTRINGLIT(tmp285,152,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient, has value: ");
  modelica_string tmp286;
  static int tmp287 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp287)
  {
    tmp284 = GreaterEq(data->simulationInfo->realParameter[470] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient PARAM */,0.0);
    if(!tmp284)
    {
      tmp286 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[470] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp285),tmp286);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead1.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp287 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7414
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7414(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7414};
  modelica_boolean tmp288;
  static const MMC_DEFSTRINGLIT(tmp289,152,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient, has value: ");
  modelica_string tmp290;
  static int tmp291 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp291)
  {
    tmp288 = GreaterEq(data->simulationInfo->realParameter[471] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient PARAM */,0.0);
    if(!tmp288)
    {
      tmp290 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[471] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp289),tmp290);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Utilities/Internal.mo",39,5,41,91,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.arrowHead2.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp291 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7415
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7415(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7415};
  modelica_boolean tmp292;
  static const MMC_DEFSTRINGLIT(tmp293,141,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient, has value: ");
  modelica_string tmp294;
  static int tmp295 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp295)
  {
    tmp292 = GreaterEq(data->simulationInfo->realParameter[476] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient PARAM */,0.0);
    if(!tmp292)
    {
      tmp294 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[476] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp293),tmp294);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1952,7,1954,127,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp295 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7416
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7416(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7416};
  modelica_boolean tmp296;
  static const MMC_DEFSTRINGLIT(tmp297,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient, has value: ");
  modelica_string tmp298;
  static int tmp299 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp299)
  {
    tmp296 = GreaterEq(data->simulationInfo->realParameter[478] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient PARAM */,0.0);
    if(!tmp296)
    {
      tmp298 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[478] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp297),tmp298);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",187,5,189,73,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.specularCoefficient >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp299 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7417
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.arrow.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.diameter, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.arrow.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7417(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7417};
  modelica_boolean tmp300;
  static const MMC_DEFSTRINGLIT(tmp301,117,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.arrow.diameter, has value: ");
  modelica_string tmp302;
  static int tmp303 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp303)
  {
    tmp300 = GreaterEq(data->simulationInfo->realParameter[375] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.diameter PARAM */,0.0);
    if(!tmp300)
    {
      tmp302 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[375] /* genericGlider_mass_explicit.buoyancyForce.force.arrow.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp301),tmp302);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1835,7,1836,52,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.arrow.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp303 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7418
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.diameter, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7418(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7418};
  modelica_boolean tmp304;
  static const MMC_DEFSTRINGLIT(tmp305,111,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.force.diameter, has value: ");
  modelica_string tmp306;
  static int tmp307 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp307)
  {
    tmp304 = GreaterEq(data->simulationInfo->realParameter[380] /* genericGlider_mass_explicit.buoyancyForce.force.diameter PARAM */,0.0);
    if(!tmp304)
    {
      tmp306 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[380] /* genericGlider_mass_explicit.buoyancyForce.force.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp305),tmp306);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",26,5,27,99,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp307 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7419
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7419(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7419};
  modelica_boolean tmp308;
  static const MMC_DEFSTRINGLIT(tmp309,126,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter, has value: ");
  modelica_string tmp310;
  static int tmp311 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp311)
  {
    tmp308 = GreaterEq(data->simulationInfo->realParameter[350] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter PARAM */,0.0);
    if(!tmp308)
    {
      tmp310 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[350] /* genericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp309),tmp310);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1835,7,1836,52,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.arrow.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp311 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7420
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.diameter, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7420(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7420};
  modelica_boolean tmp312;
  static const MMC_DEFSTRINGLIT(tmp313,120,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.force.diameter, has value: ");
  modelica_string tmp314;
  static int tmp315 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp315)
  {
    tmp312 = GreaterEq(data->simulationInfo->realParameter[352] /* genericGlider_mass_explicit.addedMassForcesTorques.force.diameter PARAM */,0.0);
    if(!tmp312)
    {
      tmp314 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[352] /* genericGlider_mass_explicit.addedMassForcesTorques.force.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp313),tmp314);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",26,5,27,99,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp315 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7421
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7421(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7421};
  modelica_boolean tmp316;
  static const MMC_DEFSTRINGLIT(tmp317,135,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter, has value: ");
  modelica_string tmp318;
  static int tmp319 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp319)
  {
    tmp316 = GreaterEq(data->simulationInfo->realParameter[339] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter PARAM */,0.0);
    if(!tmp316)
    {
      tmp318 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[339] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp317),tmp318);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1835,7,1836,52,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrow.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp319 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7422
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7422(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7422};
  modelica_boolean tmp320;
  static const MMC_DEFSTRINGLIT(tmp321,134,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter, has value: ");
  modelica_string tmp322;
  static int tmp323 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp323)
  {
    tmp320 = GreaterEq(data->simulationInfo->realParameter[341] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter PARAM */,0.0);
    if(!tmp320)
    {
      tmp322 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[341] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp321),tmp322);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",91,5,93,90,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.arrowDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp323 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7423
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7423(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7423};
  modelica_boolean tmp324;
  static const MMC_DEFSTRINGLIT(tmp325,127,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter, has value: ");
  modelica_string tmp326;
  static int tmp327 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp327)
  {
    tmp324 = GreaterEq(data->simulationInfo->realParameter[360] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter PARAM */,0.0);
    if(!tmp324)
    {
      tmp326 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[360] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp325),tmp326);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1948,7,1949,52,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.arrow.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp327 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7424
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.diameter, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7424(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7424};
  modelica_boolean tmp328;
  static const MMC_DEFSTRINGLIT(tmp329,121,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.addedMassForcesTorques.torque.diameter, has value: ");
  modelica_string tmp330;
  static int tmp331 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp331)
  {
    tmp328 = GreaterEq(data->simulationInfo->realParameter[362] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.diameter PARAM */,0.0);
    if(!tmp328)
    {
      tmp330 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[362] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp329),tmp330);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",182,5,183,100,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp331 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7425
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7425(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7425};
  modelica_boolean tmp332;
  static const MMC_DEFSTRINGLIT(tmp333,129,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter, has value: ");
  modelica_string tmp334;
  static int tmp335 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp335)
  {
    tmp332 = GreaterEq(data->simulationInfo->realParameter[465] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter PARAM */,0.0);
    if(!tmp332)
    {
      tmp334 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[465] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp333),tmp334);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1835,7,1836,52,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.arrow.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp335 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7426
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7426(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7426};
  modelica_boolean tmp336;
  static const MMC_DEFSTRINGLIT(tmp337,123,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter, has value: ");
  modelica_string tmp338;
  static int tmp339 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp339)
  {
    tmp336 = GreaterEq(data->simulationInfo->realParameter[467] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter PARAM */,0.0);
    if(!tmp336)
    {
      tmp338 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[467] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp337),tmp338);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",26,5,27,99,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp339 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7427
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7427(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7427};
  modelica_boolean tmp340;
  static const MMC_DEFSTRINGLIT(tmp341,130,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter, has value: ");
  modelica_string tmp342;
  static int tmp343 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp343)
  {
    tmp340 = GreaterEq(data->simulationInfo->realParameter[475] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter PARAM */,0.0);
    if(!tmp340)
    {
      tmp342 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[475] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp341),tmp342);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Visualizers.mo",1948,7,1949,52,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.arrow.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp343 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7428
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7428(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7428};
  modelica_boolean tmp344;
  static const MMC_DEFSTRINGLIT(tmp345,124,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter, has value: ");
  modelica_string tmp346;
  static int tmp347 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp347)
  {
    tmp344 = GreaterEq(data->simulationInfo->realParameter[477] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter PARAM */,0.0);
    if(!tmp344)
    {
      tmp346 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[477] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp345),tmp346);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",182,5,183,100,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.diameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp347 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7429
type: ALGORITHM

  assert(genericGlider_mass_explicit.m_w >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.m_w, has value: " + String(genericGlider_mass_explicit.m_w, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7429(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7429};
  modelica_boolean tmp348;
  static const MMC_DEFSTRINGLIT(tmp349,86,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.m_w, has value: ");
  modelica_string tmp350;
  static int tmp351 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp351)
  {
    tmp348 = GreaterEq(data->simulationInfo->realParameter[481] /* genericGlider_mass_explicit.m_w PARAM */,0.0);
    if(!tmp348)
    {
      tmp350 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[481] /* genericGlider_mass_explicit.m_w PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp349),tmp350);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/GenericGlider_mass_explicit.mo",14,3,14,87,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.m_w >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp351 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7430
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.ref_mass >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.ref_mass, has value: " + String(genericGlider_mass_explicit.buoyancyForce.ref_mass, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7430(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7430};
  modelica_boolean tmp352;
  static const MMC_DEFSTRINGLIT(tmp353,105,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.buoyancyForce.ref_mass, has value: ");
  modelica_string tmp354;
  static int tmp355 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp355)
  {
    tmp352 = GreaterEq(data->simulationInfo->realParameter[385] /* genericGlider_mass_explicit.buoyancyForce.ref_mass PARAM */,0.0);
    if(!tmp352)
    {
      tmp354 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[385] /* genericGlider_mass_explicit.buoyancyForce.ref_mass PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp353),tmp354);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BuoyancyForce.mo",12,3,13,43,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.ref_mass >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp355 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7431
type: ALGORITHM

  assert(ramp5.duration >= 0.0, "Variable violating min constraint: 0.0 <= ramp5.duration, has value: " + String(ramp5.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7431(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7431};
  modelica_boolean tmp356;
  static const MMC_DEFSTRINGLIT(tmp357,69,"Variable violating min constraint: 0.0 <= ramp5.duration, has value: ");
  modelica_string tmp358;
  static int tmp359 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp359)
  {
    tmp356 = GreaterEq(data->simulationInfo->realParameter[642] /* ramp5.duration PARAM */,0.0);
    if(!tmp356)
    {
      tmp358 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[642] /* ramp5.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp357),tmp358);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nramp5.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp359 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7432
type: ALGORITHM

  assert(ramp4.duration >= 0.0, "Variable violating min constraint: 0.0 <= ramp4.duration, has value: " + String(ramp4.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7432(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7432};
  modelica_boolean tmp360;
  static const MMC_DEFSTRINGLIT(tmp361,69,"Variable violating min constraint: 0.0 <= ramp4.duration, has value: ");
  modelica_string tmp362;
  static int tmp363 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp363)
  {
    tmp360 = GreaterEq(data->simulationInfo->realParameter[638] /* ramp4.duration PARAM */,0.0);
    if(!tmp360)
    {
      tmp362 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[638] /* ramp4.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp361),tmp362);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nramp4.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp363 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7433
type: ALGORITHM

  assert(ramp3.duration >= 0.0, "Variable violating min constraint: 0.0 <= ramp3.duration, has value: " + String(ramp3.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7433(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7433};
  modelica_boolean tmp364;
  static const MMC_DEFSTRINGLIT(tmp365,69,"Variable violating min constraint: 0.0 <= ramp3.duration, has value: ");
  modelica_string tmp366;
  static int tmp367 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp367)
  {
    tmp364 = GreaterEq(data->simulationInfo->realParameter[634] /* ramp3.duration PARAM */,0.0);
    if(!tmp364)
    {
      tmp366 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[634] /* ramp3.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp365),tmp366);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nramp3.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp367 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7434
type: ALGORITHM

  assert(ramp2.duration >= 0.0, "Variable violating min constraint: 0.0 <= ramp2.duration, has value: " + String(ramp2.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7434(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7434};
  modelica_boolean tmp368;
  static const MMC_DEFSTRINGLIT(tmp369,69,"Variable violating min constraint: 0.0 <= ramp2.duration, has value: ");
  modelica_string tmp370;
  static int tmp371 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp371)
  {
    tmp368 = GreaterEq(data->simulationInfo->realParameter[630] /* ramp2.duration PARAM */,0.0);
    if(!tmp368)
    {
      tmp370 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[630] /* ramp2.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp369),tmp370);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nramp2.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp371 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7435
type: ALGORITHM

  assert(ramp1.duration >= 0.0, "Variable violating min constraint: 0.0 <= ramp1.duration, has value: " + String(ramp1.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7435(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7435};
  modelica_boolean tmp372;
  static const MMC_DEFSTRINGLIT(tmp373,69,"Variable violating min constraint: 0.0 <= ramp1.duration, has value: ");
  modelica_string tmp374;
  static int tmp375 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp375)
  {
    tmp372 = GreaterEq(data->simulationInfo->realParameter[626] /* ramp1.duration PARAM */,0.0);
    if(!tmp372)
    {
      tmp374 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[626] /* ramp1.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp373),tmp374);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nramp1.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp375 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7436
type: ALGORITHM

  assert(ramp.duration >= 0.0, "Variable violating min constraint: 0.0 <= ramp.duration, has value: " + String(ramp.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7436(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7436};
  modelica_boolean tmp376;
  static const MMC_DEFSTRINGLIT(tmp377,68,"Variable violating min constraint: 0.0 <= ramp.duration, has value: ");
  modelica_string tmp378;
  static int tmp379 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp379)
  {
    tmp376 = GreaterEq(data->simulationInfo->realParameter[622] /* ramp.duration PARAM */,0.0);
    if(!tmp376)
    {
      tmp378 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[622] /* ramp.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp377),tmp378);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nramp.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp379 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7437
type: ALGORITHM

  assert(movable_mass_displacement.duration >= 0.0, "Variable violating min constraint: 0.0 <= movable_mass_displacement.duration, has value: " + String(movable_mass_displacement.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7437(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7437};
  modelica_boolean tmp380;
  static const MMC_DEFSTRINGLIT(tmp381,89,"Variable violating min constraint: 0.0 <= movable_mass_displacement.duration, has value: ");
  modelica_string tmp382;
  static int tmp383 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp383)
  {
    tmp380 = GreaterEq(data->simulationInfo->realParameter[616] /* movable_mass_displacement.duration PARAM */,0.0);
    if(!tmp380)
    {
      tmp382 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[616] /* movable_mass_displacement.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp381),tmp382);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nmovable_mass_displacement.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp383 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7438
type: ALGORITHM

  assert(VBD_mass_change.duration >= 0.0, "Variable violating min constraint: 0.0 <= VBD_mass_change.duration, has value: " + String(VBD_mass_change.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7438(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7438};
  modelica_boolean tmp384;
  static const MMC_DEFSTRINGLIT(tmp385,79,"Variable violating min constraint: 0.0 <= VBD_mass_change.duration, has value: ");
  modelica_string tmp386;
  static int tmp387 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp387)
  {
    tmp384 = GreaterEq(data->simulationInfo->realParameter[0] /* VBD_mass_change.duration PARAM */,0.0);
    if(!tmp384)
    {
      tmp386 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[0] /* VBD_mass_change.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp385),tmp386);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nVBD_mass_change.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp387 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7439
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7439(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7439};
  modelica_boolean tmp388;
  modelica_boolean tmp389;
  static const MMC_DEFSTRINGLIT(tmp390,306,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp391;
  static int tmp392 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp392)
  {
    tmp388 = GreaterEq(data->simulationInfo->integerParameter[70] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */,1);
    tmp389 = LessEq(data->simulationInfo->integerParameter[70] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */,3);
    if(!(tmp388 && tmp389))
    {
      tmp391 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[70] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp390),tmp391);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2988,7,2990,109,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp392 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7440
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7440(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7440};
  modelica_boolean tmp393;
  modelica_boolean tmp394;
  static const MMC_DEFSTRINGLIT(tmp395,305,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp396;
  static int tmp397 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp397)
  {
    tmp393 = GreaterEq(data->simulationInfo->integerParameter[69] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */,1);
    tmp394 = LessEq(data->simulationInfo->integerParameter[69] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */,3);
    if(!(tmp393 && tmp394))
    {
      tmp396 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[69] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp395),tmp396);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2985,7,2987,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp397 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7441
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7441(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7441};
  modelica_boolean tmp398;
  modelica_boolean tmp399;
  static const MMC_DEFSTRINGLIT(tmp400,285,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp401;
  static int tmp402 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp402)
  {
    tmp398 = GreaterEq(data->simulationInfo->integerParameter[72] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out PARAM */,1);
    tmp399 = LessEq(data->simulationInfo->integerParameter[72] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out PARAM */,3);
    if(!(tmp398 && tmp399))
    {
      tmp401 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[72] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp400),tmp401);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2325,5,2327,110,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp402 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7442
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7442(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7442};
  modelica_boolean tmp403;
  modelica_boolean tmp404;
  static const MMC_DEFSTRINGLIT(tmp405,284,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp406;
  static int tmp407 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp407)
  {
    tmp403 = GreaterEq(data->simulationInfo->integerParameter[71] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in PARAM */,1);
    tmp404 = LessEq(data->simulationInfo->integerParameter[71] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in PARAM */,3);
    if(!(tmp403 && tmp404))
    {
      tmp406 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[71] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp405),tmp406);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2322,5,2324,82,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp407 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7443
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7443(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7443};
  modelica_boolean tmp408;
  modelica_boolean tmp409;
  static const MMC_DEFSTRINGLIT(tmp410,274,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp411;
  static int tmp412 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp412)
  {
    tmp408 = GreaterEq(data->simulationInfo->integerParameter[67] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame PARAM */,1);
    tmp409 = LessEq(data->simulationInfo->integerParameter[67] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame PARAM */,3);
    if(!(tmp408 && tmp409))
    {
      tmp411 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[67] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp410),tmp411);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2665,7,2667,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp412 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7444
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7444(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7444};
  modelica_boolean tmp413;
  modelica_boolean tmp414;
  static const MMC_DEFSTRINGLIT(tmp415,265,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp416;
  static int tmp417 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp417)
  {
    tmp413 = GreaterEq(data->simulationInfo->integerParameter[68] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame PARAM */,1);
    tmp414 = LessEq(data->simulationInfo->integerParameter[68] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame PARAM */,3);
    if(!(tmp413 && tmp414))
    {
      tmp416 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[68] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp415),tmp416);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1007,5,1009,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp417 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7445
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7445(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7445};
  modelica_boolean tmp418;
  modelica_boolean tmp419;
  static const MMC_DEFSTRINGLIT(tmp420,288,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp421;
  static int tmp422 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp422)
  {
    tmp418 = GreaterEq(data->simulationInfo->integerParameter[65] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame PARAM */,1);
    tmp419 = LessEq(data->simulationInfo->integerParameter[65] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame PARAM */,3);
    if(!(tmp418 && tmp419))
    {
      tmp421 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[65] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp420),tmp421);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2740,7,2743,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp422 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7446
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7446(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7446};
  modelica_boolean tmp423;
  modelica_boolean tmp424;
  static const MMC_DEFSTRINGLIT(tmp425,272,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp426;
  static int tmp427 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp427)
  {
    tmp423 = GreaterEq(data->simulationInfo->integerParameter[66] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame PARAM */,1);
    tmp424 = LessEq(data->simulationInfo->integerParameter[66] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame PARAM */,3);
    if(!(tmp423 && tmp424))
    {
      tmp426 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[66] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp425),tmp426);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1214,5,1216,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp427 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7447
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7447(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7447};
  modelica_boolean tmp428;
  modelica_boolean tmp429;
  static const MMC_DEFSTRINGLIT(tmp430,272,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp431;
  static int tmp432 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp432)
  {
    tmp428 = GreaterEq(data->simulationInfo->integerParameter[75] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame PARAM */,1);
    tmp429 = LessEq(data->simulationInfo->integerParameter[75] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame PARAM */,3);
    if(!(tmp428 && tmp429))
    {
      tmp431 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[75] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp430),tmp431);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",2831,7,2834,85,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp432 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7448
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.defaultNm_to_m >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.defaultNm_to_m, has value: " + String(genericGlider_mass_explicit.world.defaultNm_to_m, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7448(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7448};
  modelica_boolean tmp433;
  static const MMC_DEFSTRINGLIT(tmp434,103,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.defaultNm_to_m, has value: ");
  modelica_string tmp435;
  static int tmp436 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp436)
  {
    tmp433 = GreaterEq(data->simulationInfo->realParameter[518] /* genericGlider_mass_explicit.world.defaultNm_to_m PARAM */,0.0);
    if(!tmp433)
    {
      tmp435 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[518] /* genericGlider_mass_explicit.world.defaultNm_to_m PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp434),tmp435);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1181,3,1183,40,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.defaultNm_to_m >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp436 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7449
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7449(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7449};
  modelica_boolean tmp437;
  modelica_boolean tmp438;
  static const MMC_DEFSTRINGLIT(tmp439,255,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp440;
  static int tmp441 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp441)
  {
    tmp437 = GreaterEq(data->simulationInfo->integerParameter[76] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame PARAM */,1);
    tmp438 = LessEq(data->simulationInfo->integerParameter[76] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame PARAM */,3);
    if(!(tmp437 && tmp438))
    {
      tmp440 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[76] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp439),tmp440);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",176,5,178,89,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp441 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7450
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7450(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7450};
  modelica_boolean tmp442;
  modelica_boolean tmp443;
  static const MMC_DEFSTRINGLIT(tmp444,270,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp445;
  static int tmp446 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp446)
  {
    tmp442 = GreaterEq(data->simulationInfo->integerParameter[73] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame PARAM */,1);
    tmp443 = LessEq(data->simulationInfo->integerParameter[73] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame PARAM */,3);
    if(!(tmp442 && tmp443))
    {
      tmp445 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[73] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp444),tmp445);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",2733,7,2736,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp446 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7451
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.defaultN_to_m >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.defaultN_to_m, has value: " + String(genericGlider_mass_explicit.world.defaultN_to_m, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7451(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7451};
  modelica_boolean tmp447;
  static const MMC_DEFSTRINGLIT(tmp448,102,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.defaultN_to_m, has value: ");
  modelica_string tmp449;
  static int tmp450 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp450)
  {
    tmp447 = GreaterEq(data->simulationInfo->realParameter[517] /* genericGlider_mass_explicit.world.defaultN_to_m PARAM */,0.0);
    if(!tmp447)
    {
      tmp449 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[517] /* genericGlider_mass_explicit.world.defaultN_to_m PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp448),tmp449);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1178,3,1180,40,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.defaultN_to_m >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp450 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7452
type: ALGORITHM

  assert(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7452(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7452};
  modelica_boolean tmp451;
  modelica_boolean tmp452;
  static const MMC_DEFSTRINGLIT(tmp453,254,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp454;
  static int tmp455 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp455)
  {
    tmp451 = GreaterEq(data->simulationInfo->integerParameter[74] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame PARAM */,1);
    tmp452 = LessEq(data->simulationInfo->integerParameter[74] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame PARAM */,3);
    if(!(tmp451 && tmp452))
    {
      tmp454 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[74] /* genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp453),tmp454);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",20,5,22,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.hydrodynamicForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp455 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7453
type: ALGORITHM

  assert(genericGlider_mass_explicit.rOS_Sampler.samplePeriod >= 1e-13, "Variable violating min constraint: 1e-13 <= genericGlider_mass_explicit.rOS_Sampler.samplePeriod, has value: " + String(genericGlider_mass_explicit.rOS_Sampler.samplePeriod, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7453(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7453};
  modelica_boolean tmp456;
  static const MMC_DEFSTRINGLIT(tmp457,109,"Variable violating min constraint: 1e-13 <= genericGlider_mass_explicit.rOS_Sampler.samplePeriod, has value: ");
  modelica_string tmp458;
  static int tmp459 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp459)
  {
    tmp456 = GreaterEq(data->simulationInfo->realParameter[482] /* genericGlider_mass_explicit.rOS_Sampler.samplePeriod PARAM */,1e-13);
    if(!tmp456)
    {
      tmp458 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[482] /* genericGlider_mass_explicit.rOS_Sampler.samplePeriod PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp457),tmp458);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Interfaces.mo",561,5,562,35,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.rOS_Sampler.samplePeriod >= 1e-13", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp459 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7454
type: ALGORITHM

  assert(genericGlider_mass_explicit.absolutePosition.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.absolutePosition.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.absolutePosition.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.absolutePosition.position.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7454(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7454};
  modelica_boolean tmp460;
  modelica_boolean tmp461;
  static const MMC_DEFSTRINGLIT(tmp462,248,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.absolutePosition.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp463;
  static int tmp464 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp464)
  {
    tmp460 = GreaterEq(data->simulationInfo->integerParameter[3] /* genericGlider_mass_explicit.absolutePosition.position.resolveInFrame PARAM */,1);
    tmp461 = LessEq(data->simulationInfo->integerParameter[3] /* genericGlider_mass_explicit.absolutePosition.position.resolveInFrame PARAM */,3);
    if(!(tmp460 && tmp461))
    {
      tmp463 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[3] /* genericGlider_mass_explicit.absolutePosition.position.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp462),tmp463);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2665,7,2667,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.absolutePosition.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.absolutePosition.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp464 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7455
type: ALGORITHM

  assert(genericGlider_mass_explicit.absolutePosition.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.absolutePosition.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.absolutePosition.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.absolutePosition.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7455(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7455};
  modelica_boolean tmp465;
  modelica_boolean tmp466;
  static const MMC_DEFSTRINGLIT(tmp467,239,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.absolutePosition.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp468;
  static int tmp469 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp469)
  {
    tmp465 = GreaterEq(data->simulationInfo->integerParameter[4] /* genericGlider_mass_explicit.absolutePosition.resolveInFrame PARAM */,1);
    tmp466 = LessEq(data->simulationInfo->integerParameter[4] /* genericGlider_mass_explicit.absolutePosition.resolveInFrame PARAM */,3);
    if(!(tmp465 && tmp466))
    {
      tmp468 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[4] /* genericGlider_mass_explicit.absolutePosition.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp467),tmp468);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",900,5,902,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.absolutePosition.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.absolutePosition.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp469 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7456
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7456(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7456};
  modelica_boolean tmp470;
  modelica_boolean tmp471;
  static const MMC_DEFSTRINGLIT(tmp472,269,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp473;
  static int tmp474 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp474)
  {
    tmp470 = GreaterEq(data->simulationInfo->integerParameter[55] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame PARAM */,1);
    tmp471 = LessEq(data->simulationInfo->integerParameter[55] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame PARAM */,3);
    if(!(tmp470 && tmp471))
    {
      tmp473 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[55] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp472),tmp473);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",2831,7,2834,85,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.torque.basicWorldTorque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp474 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7457
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7457(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7457};
  modelica_boolean tmp475;
  modelica_boolean tmp476;
  static const MMC_DEFSTRINGLIT(tmp477,252,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp478;
  static int tmp479 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp479)
  {
    tmp475 = GreaterEq(data->simulationInfo->integerParameter[56] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame PARAM */,1);
    tmp476 = LessEq(data->simulationInfo->integerParameter[56] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame PARAM */,3);
    if(!(tmp475 && tmp476))
    {
      tmp478 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[56] /* genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp477),tmp478);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",176,5,178,89,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.torque.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp479 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7458
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7458(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7458};
  modelica_boolean tmp480;
  modelica_boolean tmp481;
  static const MMC_DEFSTRINGLIT(tmp482,300,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp483;
  static int tmp484 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp484)
  {
    tmp480 = GreaterEq(data->simulationInfo->integerParameter[25] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame PARAM */,1);
    tmp481 = LessEq(data->simulationInfo->integerParameter[25] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame PARAM */,3);
    if(!(tmp480 && tmp481))
    {
      tmp483 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[25] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp482),tmp483);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2740,7,2743,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp484 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7459
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7459(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7459};
  modelica_boolean tmp485;
  modelica_boolean tmp486;
  static const MMC_DEFSTRINGLIT(tmp487,284,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp488;
  static int tmp489 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp489)
  {
    tmp485 = GreaterEq(data->simulationInfo->integerParameter[26] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame PARAM */,1);
    tmp486 = LessEq(data->simulationInfo->integerParameter[26] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame PARAM */,3);
    if(!(tmp485 && tmp486))
    {
      tmp488 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[26] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp487),tmp488);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1214,5,1216,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteAngularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp489 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7460
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7460(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7460};
  modelica_boolean tmp490;
  modelica_boolean tmp491;
  static const MMC_DEFSTRINGLIT(tmp492,318,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp493;
  static int tmp494 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp494)
  {
    tmp490 = GreaterEq(data->simulationInfo->integerParameter[30] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */,1);
    tmp491 = LessEq(data->simulationInfo->integerParameter[30] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */,3);
    if(!(tmp490 && tmp491))
    {
      tmp493 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[30] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp492),tmp493);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2988,7,2990,109,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp494 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7461
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7461(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7461};
  modelica_boolean tmp495;
  modelica_boolean tmp496;
  static const MMC_DEFSTRINGLIT(tmp497,317,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp498;
  static int tmp499 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp499)
  {
    tmp495 = GreaterEq(data->simulationInfo->integerParameter[29] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */,1);
    tmp496 = LessEq(data->simulationInfo->integerParameter[29] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */,3);
    if(!(tmp495 && tmp496))
    {
      tmp498 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[29] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp497),tmp498);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2985,7,2987,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp499 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7462
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7462(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7462};
  modelica_boolean tmp500;
  modelica_boolean tmp501;
  static const MMC_DEFSTRINGLIT(tmp502,297,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp503;
  static int tmp504 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp504)
  {
    tmp500 = GreaterEq(data->simulationInfo->integerParameter[32] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out PARAM */,1);
    tmp501 = LessEq(data->simulationInfo->integerParameter[32] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out PARAM */,3);
    if(!(tmp500 && tmp501))
    {
      tmp503 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[32] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp502),tmp503);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2325,5,2327,110,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp504 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7463
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7463(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7463};
  modelica_boolean tmp505;
  modelica_boolean tmp506;
  static const MMC_DEFSTRINGLIT(tmp507,296,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp508;
  static int tmp509 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp509)
  {
    tmp505 = GreaterEq(data->simulationInfo->integerParameter[31] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in PARAM */,1);
    tmp506 = LessEq(data->simulationInfo->integerParameter[31] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in PARAM */,3);
    if(!(tmp505 && tmp506))
    {
      tmp508 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[31] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp507),tmp508);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2322,5,2324,82,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp509 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7464
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7464(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7464};
  modelica_boolean tmp510;
  modelica_boolean tmp511;
  static const MMC_DEFSTRINGLIT(tmp512,286,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp513;
  static int tmp514 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp514)
  {
    tmp510 = GreaterEq(data->simulationInfo->integerParameter[27] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame PARAM */,1);
    tmp511 = LessEq(data->simulationInfo->integerParameter[27] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame PARAM */,3);
    if(!(tmp510 && tmp511))
    {
      tmp513 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[27] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp512),tmp513);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2665,7,2667,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp514 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7465
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7465(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7465};
  modelica_boolean tmp515;
  modelica_boolean tmp516;
  static const MMC_DEFSTRINGLIT(tmp517,277,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp518;
  static int tmp519 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp519)
  {
    tmp515 = GreaterEq(data->simulationInfo->integerParameter[28] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame PARAM */,1);
    tmp516 = LessEq(data->simulationInfo->integerParameter[28] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame PARAM */,3);
    if(!(tmp515 && tmp516))
    {
      tmp518 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[28] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp517),tmp518);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1007,5,1009,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.absoluteVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp519 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7466
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7466(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7466};
  modelica_boolean tmp520;
  modelica_boolean tmp521;
  static const MMC_DEFSTRINGLIT(tmp522,296,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp523;
  static int tmp524 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp524)
  {
    tmp520 = GreaterEq(data->simulationInfo->integerParameter[44] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out PARAM */,1);
    tmp521 = LessEq(data->simulationInfo->integerParameter[44] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out PARAM */,3);
    if(!(tmp520 && tmp521))
    {
      tmp523 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[44] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp522),tmp523);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2988,7,2990,109,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp524 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7467
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7467(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7467};
  modelica_boolean tmp525;
  modelica_boolean tmp526;
  static const MMC_DEFSTRINGLIT(tmp527,295,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp528;
  static int tmp529 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp529)
  {
    tmp525 = GreaterEq(data->simulationInfo->integerParameter[43] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in PARAM */,1);
    tmp526 = LessEq(data->simulationInfo->integerParameter[43] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in PARAM */,3);
    if(!(tmp525 && tmp526))
    {
      tmp528 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[43] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp527),tmp528);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2985,7,2987,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp529 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7468
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7468(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7468};
  modelica_boolean tmp530;
  modelica_boolean tmp531;
  static const MMC_DEFSTRINGLIT(tmp532,275,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp533;
  static int tmp534 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp534)
  {
    tmp530 = GreaterEq(data->simulationInfo->integerParameter[46] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out PARAM */,1);
    tmp531 = LessEq(data->simulationInfo->integerParameter[46] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out PARAM */,3);
    if(!(tmp530 && tmp531))
    {
      tmp533 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[46] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp532),tmp533);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2325,5,2327,110,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp534 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7469
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7469(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7469};
  modelica_boolean tmp535;
  modelica_boolean tmp536;
  static const MMC_DEFSTRINGLIT(tmp537,274,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp538;
  static int tmp539 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp539)
  {
    tmp535 = GreaterEq(data->simulationInfo->integerParameter[45] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in PARAM */,1);
    tmp536 = LessEq(data->simulationInfo->integerParameter[45] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in PARAM */,3);
    if(!(tmp535 && tmp536))
    {
      tmp538 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[45] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp537),tmp538);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2322,5,2324,82,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_z.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp539 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7470
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7470(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7470};
  modelica_boolean tmp540;
  modelica_boolean tmp541;
  static const MMC_DEFSTRINGLIT(tmp542,296,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp543;
  static int tmp544 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp544)
  {
    tmp540 = GreaterEq(data->simulationInfo->integerParameter[40] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out PARAM */,1);
    tmp541 = LessEq(data->simulationInfo->integerParameter[40] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out PARAM */,3);
    if(!(tmp540 && tmp541))
    {
      tmp543 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[40] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp542),tmp543);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2988,7,2990,109,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp544 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7471
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7471(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7471};
  modelica_boolean tmp545;
  modelica_boolean tmp546;
  static const MMC_DEFSTRINGLIT(tmp547,295,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp548;
  static int tmp549 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp549)
  {
    tmp545 = GreaterEq(data->simulationInfo->integerParameter[39] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in PARAM */,1);
    tmp546 = LessEq(data->simulationInfo->integerParameter[39] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in PARAM */,3);
    if(!(tmp545 && tmp546))
    {
      tmp548 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[39] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp547),tmp548);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2985,7,2987,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp549 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7472
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7472(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7472};
  modelica_boolean tmp550;
  modelica_boolean tmp551;
  static const MMC_DEFSTRINGLIT(tmp552,275,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp553;
  static int tmp554 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp554)
  {
    tmp550 = GreaterEq(data->simulationInfo->integerParameter[42] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out PARAM */,1);
    tmp551 = LessEq(data->simulationInfo->integerParameter[42] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out PARAM */,3);
    if(!(tmp550 && tmp551))
    {
      tmp553 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[42] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp552),tmp553);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2325,5,2327,110,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp554 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7473
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7473(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7473};
  modelica_boolean tmp555;
  modelica_boolean tmp556;
  static const MMC_DEFSTRINGLIT(tmp557,274,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp558;
  static int tmp559 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp559)
  {
    tmp555 = GreaterEq(data->simulationInfo->integerParameter[41] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in PARAM */,1);
    tmp556 = LessEq(data->simulationInfo->integerParameter[41] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in PARAM */,3);
    if(!(tmp555 && tmp556))
    {
      tmp558 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[41] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp557),tmp558);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2322,5,2324,82,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.transformVector_a.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp559 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7474
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7474(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7474};
  modelica_boolean tmp560;
  modelica_boolean tmp561;
  static const MMC_DEFSTRINGLIT(tmp562,292,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp563;
  static int tmp564 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp564)
  {
    tmp560 = GreaterEq(data->simulationInfo->integerParameter[33] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame PARAM */,1);
    tmp561 = LessEq(data->simulationInfo->integerParameter[33] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame PARAM */,3);
    if(!(tmp560 && tmp561))
    {
      tmp563 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[33] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp562),tmp563);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2740,7,2743,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp564 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7475
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7475(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7475};
  modelica_boolean tmp565;
  modelica_boolean tmp566;
  static const MMC_DEFSTRINGLIT(tmp567,276,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp568;
  static int tmp569 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp569)
  {
    tmp565 = GreaterEq(data->simulationInfo->integerParameter[34] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame PARAM */,1);
    tmp566 = LessEq(data->simulationInfo->integerParameter[34] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame PARAM */,3);
    if(!(tmp565 && tmp566))
    {
      tmp568 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[34] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp567),tmp568);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1214,5,1216,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.angularVelocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp569 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7476
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7476(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7476};
  modelica_boolean tmp570;
  modelica_boolean tmp571;
  static const MMC_DEFSTRINGLIT(tmp572,310,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp573;
  static int tmp574 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp574)
  {
    tmp570 = GreaterEq(data->simulationInfo->integerParameter[50] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */,1);
    tmp571 = LessEq(data->simulationInfo->integerParameter[50] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */,3);
    if(!(tmp570 && tmp571))
    {
      tmp573 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[50] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp572),tmp573);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2988,7,2990,109,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp574 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7477
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7477(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7477};
  modelica_boolean tmp575;
  modelica_boolean tmp576;
  static const MMC_DEFSTRINGLIT(tmp577,309,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp578;
  static int tmp579 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp579)
  {
    tmp575 = GreaterEq(data->simulationInfo->integerParameter[49] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */,1);
    tmp576 = LessEq(data->simulationInfo->integerParameter[49] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */,3);
    if(!(tmp575 && tmp576))
    {
      tmp578 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[49] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp577),tmp578);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2985,7,2987,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.basicTransformVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp579 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7478
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7478(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7478};
  modelica_boolean tmp580;
  modelica_boolean tmp581;
  static const MMC_DEFSTRINGLIT(tmp582,289,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp583;
  static int tmp584 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp584)
  {
    tmp580 = GreaterEq(data->simulationInfo->integerParameter[52] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out PARAM */,1);
    tmp581 = LessEq(data->simulationInfo->integerParameter[52] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out PARAM */,3);
    if(!(tmp580 && tmp581))
    {
      tmp583 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[52] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp582),tmp583);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2325,5,2327,110,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_out <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp584 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7479
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7479(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7479};
  modelica_boolean tmp585;
  modelica_boolean tmp586;
  static const MMC_DEFSTRINGLIT(tmp587,288,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp588;
  static int tmp589 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp589)
  {
    tmp585 = GreaterEq(data->simulationInfo->integerParameter[51] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in PARAM */,1);
    tmp586 = LessEq(data->simulationInfo->integerParameter[51] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in PARAM */,3);
    if(!(tmp585 && tmp586))
    {
      tmp588 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[51] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp587),tmp588);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2322,5,2324,82,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.tansformAbsoluteVector.frame_r_in <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp589 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7480
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7480(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7480};
  modelica_boolean tmp590;
  modelica_boolean tmp591;
  static const MMC_DEFSTRINGLIT(tmp592,278,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp593;
  static int tmp594 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp594)
  {
    tmp590 = GreaterEq(data->simulationInfo->integerParameter[47] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame PARAM */,1);
    tmp591 = LessEq(data->simulationInfo->integerParameter[47] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame PARAM */,3);
    if(!(tmp590 && tmp591))
    {
      tmp593 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[47] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp592),tmp593);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",2665,7,2667,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.position.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp594 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7481
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7481(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7481};
  modelica_boolean tmp595;
  modelica_boolean tmp596;
  static const MMC_DEFSTRINGLIT(tmp597,269,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp598;
  static int tmp599 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp599)
  {
    tmp595 = GreaterEq(data->simulationInfo->integerParameter[48] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame PARAM */,1);
    tmp596 = LessEq(data->simulationInfo->integerParameter[48] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame PARAM */,3);
    if(!(tmp595 && tmp596))
    {
      tmp598 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[48] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp597),tmp598);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1007,5,1009,92,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.velocity.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp599 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7482
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] >= 1 and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] <= 3, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7482(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7482};
  modelica_boolean tmp600;
  modelica_boolean tmp601;
  static const MMC_DEFSTRINGLIT(tmp602,139,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] <= 3, has value: ");
  modelica_string tmp603;
  static int tmp604 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp604)
  {
    tmp600 = GreaterEq(data->simulationInfo->integerParameter[38] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] PARAM */,((modelica_integer) 1));
    tmp601 = LessEq(data->simulationInfo->integerParameter[38] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] PARAM */,((modelica_integer) 3));
    if(!(tmp600 && tmp601))
    {
      tmp603 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[38] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp602),tmp603);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",82,5,86,172,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] >= 1 and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp604 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7483
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] >= 1 and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] <= 3, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7483(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7483};
  modelica_boolean tmp605;
  modelica_boolean tmp606;
  static const MMC_DEFSTRINGLIT(tmp607,139,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] <= 3, has value: ");
  modelica_string tmp608;
  static int tmp609 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp609)
  {
    tmp605 = GreaterEq(data->simulationInfo->integerParameter[37] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] PARAM */,((modelica_integer) 1));
    tmp606 = LessEq(data->simulationInfo->integerParameter[37] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] PARAM */,((modelica_integer) 3));
    if(!(tmp605 && tmp606))
    {
      tmp608 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[37] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp607),tmp608);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",82,5,86,172,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] >= 1 and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp609 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7484
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] >= 1 and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] <= 3, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7484(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7484};
  modelica_boolean tmp610;
  modelica_boolean tmp611;
  static const MMC_DEFSTRINGLIT(tmp612,139,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] <= 3, has value: ");
  modelica_string tmp613;
  static int tmp614 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp614)
  {
    tmp610 = GreaterEq(data->simulationInfo->integerParameter[36] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] PARAM */,((modelica_integer) 1));
    tmp611 = LessEq(data->simulationInfo->integerParameter[36] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] PARAM */,((modelica_integer) 3));
    if(!(tmp610 && tmp611))
    {
      tmp613 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[36] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp612),tmp613);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",82,5,86,172,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] >= 1 and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.sequence[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp614 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7485
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7485(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7485};
  modelica_boolean tmp615;
  modelica_boolean tmp616;
  static const MMC_DEFSTRINGLIT(tmp617,260,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world <= genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve, has value: ");
  modelica_string tmp618;
  static int tmp619 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp619)
  {
    tmp615 = GreaterEq(data->simulationInfo->integerParameter[35] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame PARAM */,1);
    tmp616 = LessEq(data->simulationInfo->integerParameter[35] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame PARAM */,3);
    if(!(tmp615 && tmp616))
    {
      tmp618 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[35] /* genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp617),tmp618);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",61,5,63,79,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world and genericGlider_mass_explicit.addedMassForcesTorques.absoluteSensor.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp619 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7486
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7486(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7486};
  modelica_boolean tmp620;
  modelica_boolean tmp621;
  static const MMC_DEFSTRINGLIT(tmp622,267,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp623;
  static int tmp624 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp624)
  {
    tmp620 = GreaterEq(data->simulationInfo->integerParameter[53] /* genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame PARAM */,1);
    tmp621 = LessEq(data->simulationInfo->integerParameter[53] /* genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame PARAM */,3);
    if(!(tmp620 && tmp621))
    {
      tmp623 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[53] /* genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp622),tmp623);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",2733,7,2736,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp624 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7487
type: ALGORITHM

  assert(genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7487(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7487};
  modelica_boolean tmp625;
  modelica_boolean tmp626;
  static const MMC_DEFSTRINGLIT(tmp627,251,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp628;
  static int tmp629 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp629)
  {
    tmp625 = GreaterEq(data->simulationInfo->integerParameter[54] /* genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame PARAM */,1);
    tmp626 = LessEq(data->simulationInfo->integerParameter[54] /* genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame PARAM */,3);
    if(!(tmp625 && tmp626))
    {
      tmp628 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[54] /* genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp627),tmp628);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",20,5,22,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.addedMassForcesTorques.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp629 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7488
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.I_33 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.I_33, has value: " + String(genericGlider_mass_explicit.hull.I_33, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7488(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7488};
  modelica_boolean tmp630;
  static const MMC_DEFSTRINGLIT(tmp631,92,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.I_33, has value: ");
  modelica_string tmp632;
  static int tmp633 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp633)
  {
    tmp630 = GreaterEq(data->simulationInfo->realParameter[403] /* genericGlider_mass_explicit.hull.I_33 PARAM */,0.0);
    if(!tmp630)
    {
      tmp632 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[403] /* genericGlider_mass_explicit.hull.I_33 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp631),tmp632);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",644,5,646,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.I_33 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp633 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7489
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.I_32 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.hull.I_32, has value: " + String(genericGlider_mass_explicit.hull.I_32, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7489(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7489};
  modelica_boolean tmp634;
  static const MMC_DEFSTRINGLIT(tmp635,111,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.hull.I_32, has value: ");
  modelica_string tmp636;
  static int tmp637 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp637)
  {
    tmp634 = GreaterEq(data->simulationInfo->realParameter[402] /* genericGlider_mass_explicit.hull.I_32 PARAM */,-9.999999999999999e+59);
    if(!tmp634)
    {
      tmp636 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[402] /* genericGlider_mass_explicit.hull.I_32 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp635),tmp636);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",653,5,655,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.I_32 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp637 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7490
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.I_31 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.hull.I_31, has value: " + String(genericGlider_mass_explicit.hull.I_31, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7490(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7490};
  modelica_boolean tmp638;
  static const MMC_DEFSTRINGLIT(tmp639,111,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.hull.I_31, has value: ");
  modelica_string tmp640;
  static int tmp641 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp641)
  {
    tmp638 = GreaterEq(data->simulationInfo->realParameter[401] /* genericGlider_mass_explicit.hull.I_31 PARAM */,-9.999999999999999e+59);
    if(!tmp638)
    {
      tmp640 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[401] /* genericGlider_mass_explicit.hull.I_31 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp639),tmp640);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",650,5,652,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.I_31 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp641 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7491
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.I_22 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.I_22, has value: " + String(genericGlider_mass_explicit.hull.I_22, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7491(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7491};
  modelica_boolean tmp642;
  static const MMC_DEFSTRINGLIT(tmp643,92,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.I_22, has value: ");
  modelica_string tmp644;
  static int tmp645 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp645)
  {
    tmp642 = GreaterEq(data->simulationInfo->realParameter[400] /* genericGlider_mass_explicit.hull.I_22 PARAM */,0.0);
    if(!tmp642)
    {
      tmp644 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[400] /* genericGlider_mass_explicit.hull.I_22 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp643),tmp644);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",641,5,643,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.I_22 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp645 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7492
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.I_21 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.hull.I_21, has value: " + String(genericGlider_mass_explicit.hull.I_21, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7492(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7492};
  modelica_boolean tmp646;
  static const MMC_DEFSTRINGLIT(tmp647,111,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.hull.I_21, has value: ");
  modelica_string tmp648;
  static int tmp649 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp649)
  {
    tmp646 = GreaterEq(data->simulationInfo->realParameter[399] /* genericGlider_mass_explicit.hull.I_21 PARAM */,-9.999999999999999e+59);
    if(!tmp646)
    {
      tmp648 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[399] /* genericGlider_mass_explicit.hull.I_21 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp647),tmp648);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",647,5,649,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.I_21 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp649 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7493
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.I_11 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.I_11, has value: " + String(genericGlider_mass_explicit.hull.I_11, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7493(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7493};
  modelica_boolean tmp650;
  static const MMC_DEFSTRINGLIT(tmp651,92,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.I_11, has value: ");
  modelica_string tmp652;
  static int tmp653 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp653)
  {
    tmp650 = GreaterEq(data->simulationInfo->realParameter[398] /* genericGlider_mass_explicit.hull.I_11 PARAM */,0.0);
    if(!tmp650)
    {
      tmp652 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[398] /* genericGlider_mass_explicit.hull.I_11 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp651),tmp652);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",638,5,640,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.I_11 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp653 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7494
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sequence_angleStates[3] >= 1 and genericGlider_mass_explicit.hull.sequence_angleStates[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_angleStates[3] <= 3, has value: " + String(genericGlider_mass_explicit.hull.sequence_angleStates[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7494(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7494};
  modelica_boolean tmp654;
  modelica_boolean tmp655;
  static const MMC_DEFSTRINGLIT(tmp656,118,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_angleStates[3] <= 3, has value: ");
  modelica_string tmp657;
  static int tmp658 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp658)
  {
    tmp654 = GreaterEq(data->simulationInfo->integerParameter[61] /* genericGlider_mass_explicit.hull.sequence_angleStates[3] PARAM */,((modelica_integer) 1));
    tmp655 = LessEq(data->simulationInfo->integerParameter[61] /* genericGlider_mass_explicit.hull.sequence_angleStates[3] PARAM */,((modelica_integer) 3));
    if(!(tmp654 && tmp655))
    {
      tmp657 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[61] /* genericGlider_mass_explicit.hull.sequence_angleStates[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp656),tmp657);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",736,5,739,29,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sequence_angleStates[3] >= 1 and genericGlider_mass_explicit.hull.sequence_angleStates[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp658 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7495
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sequence_angleStates[2] >= 1 and genericGlider_mass_explicit.hull.sequence_angleStates[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_angleStates[2] <= 3, has value: " + String(genericGlider_mass_explicit.hull.sequence_angleStates[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7495(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7495};
  modelica_boolean tmp659;
  modelica_boolean tmp660;
  static const MMC_DEFSTRINGLIT(tmp661,118,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_angleStates[2] <= 3, has value: ");
  modelica_string tmp662;
  static int tmp663 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp663)
  {
    tmp659 = GreaterEq(data->simulationInfo->integerParameter[60] /* genericGlider_mass_explicit.hull.sequence_angleStates[2] PARAM */,((modelica_integer) 1));
    tmp660 = LessEq(data->simulationInfo->integerParameter[60] /* genericGlider_mass_explicit.hull.sequence_angleStates[2] PARAM */,((modelica_integer) 3));
    if(!(tmp659 && tmp660))
    {
      tmp662 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[60] /* genericGlider_mass_explicit.hull.sequence_angleStates[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp661),tmp662);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",736,5,739,29,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sequence_angleStates[2] >= 1 and genericGlider_mass_explicit.hull.sequence_angleStates[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp663 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7496
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sequence_angleStates[1] >= 1 and genericGlider_mass_explicit.hull.sequence_angleStates[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_angleStates[1] <= 3, has value: " + String(genericGlider_mass_explicit.hull.sequence_angleStates[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7496(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7496};
  modelica_boolean tmp664;
  modelica_boolean tmp665;
  static const MMC_DEFSTRINGLIT(tmp666,118,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_angleStates[1] <= 3, has value: ");
  modelica_string tmp667;
  static int tmp668 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp668)
  {
    tmp664 = GreaterEq(data->simulationInfo->integerParameter[59] /* genericGlider_mass_explicit.hull.sequence_angleStates[1] PARAM */,((modelica_integer) 1));
    tmp665 = LessEq(data->simulationInfo->integerParameter[59] /* genericGlider_mass_explicit.hull.sequence_angleStates[1] PARAM */,((modelica_integer) 3));
    if(!(tmp664 && tmp665))
    {
      tmp667 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[59] /* genericGlider_mass_explicit.hull.sequence_angleStates[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp666),tmp667);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",736,5,739,29,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sequence_angleStates[1] >= 1 and genericGlider_mass_explicit.hull.sequence_angleStates[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp668 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7497
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sphereDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.sphereDiameter, has value: " + String(genericGlider_mass_explicit.hull.sphereDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7497(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7497};
  modelica_boolean tmp669;
  static const MMC_DEFSTRINGLIT(tmp670,102,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.sphereDiameter, has value: ");
  modelica_string tmp671;
  static int tmp672 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp672)
  {
    tmp669 = GreaterEq(data->simulationInfo->realParameter[432] /* genericGlider_mass_explicit.hull.sphereDiameter PARAM */,0.0);
    if(!tmp669)
    {
      tmp671 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[432] /* genericGlider_mass_explicit.hull.sphereDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp670),tmp671);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",702,5,706,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sphereDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp672 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7498
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.cylinderDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.cylinderDiameter, has value: " + String(genericGlider_mass_explicit.hull.cylinderDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7498(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7498};
  modelica_boolean tmp673;
  static const MMC_DEFSTRINGLIT(tmp674,104,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.cylinderDiameter, has value: ");
  modelica_string tmp675;
  static int tmp676 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp676)
  {
    tmp673 = GreaterEq(data->simulationInfo->realParameter[423] /* genericGlider_mass_explicit.hull.cylinderDiameter PARAM */,0.0);
    if(!tmp673)
    {
      tmp675 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[423] /* genericGlider_mass_explicit.hull.cylinderDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp674),tmp675);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",713,5,717,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.cylinderDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp676 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7499
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sequence_start[3] >= 1 and genericGlider_mass_explicit.hull.sequence_start[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_start[3] <= 3, has value: " + String(genericGlider_mass_explicit.hull.sequence_start[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7499(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7499};
  modelica_boolean tmp677;
  modelica_boolean tmp678;
  static const MMC_DEFSTRINGLIT(tmp679,112,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_start[3] <= 3, has value: ");
  modelica_string tmp680;
  static int tmp681 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp681)
  {
    tmp677 = GreaterEq(data->simulationInfo->integerParameter[64] /* genericGlider_mass_explicit.hull.sequence_start[3] PARAM */,((modelica_integer) 1));
    tmp678 = LessEq(data->simulationInfo->integerParameter[64] /* genericGlider_mass_explicit.hull.sequence_start[3] PARAM */,((modelica_integer) 3));
    if(!(tmp677 && tmp678))
    {
      tmp680 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[64] /* genericGlider_mass_explicit.hull.sequence_start[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp679),tmp680);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",678,5,680,63,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sequence_start[3] >= 1 and genericGlider_mass_explicit.hull.sequence_start[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp681 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7500
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sequence_start[2] >= 1 and genericGlider_mass_explicit.hull.sequence_start[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_start[2] <= 3, has value: " + String(genericGlider_mass_explicit.hull.sequence_start[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7500(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7500};
  modelica_boolean tmp682;
  modelica_boolean tmp683;
  static const MMC_DEFSTRINGLIT(tmp684,112,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_start[2] <= 3, has value: ");
  modelica_string tmp685;
  static int tmp686 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp686)
  {
    tmp682 = GreaterEq(data->simulationInfo->integerParameter[63] /* genericGlider_mass_explicit.hull.sequence_start[2] PARAM */,((modelica_integer) 1));
    tmp683 = LessEq(data->simulationInfo->integerParameter[63] /* genericGlider_mass_explicit.hull.sequence_start[2] PARAM */,((modelica_integer) 3));
    if(!(tmp682 && tmp683))
    {
      tmp685 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[63] /* genericGlider_mass_explicit.hull.sequence_start[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp684),tmp685);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",678,5,680,63,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sequence_start[2] >= 1 and genericGlider_mass_explicit.hull.sequence_start[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp686 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7501
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.sequence_start[1] >= 1 and genericGlider_mass_explicit.hull.sequence_start[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_start[1] <= 3, has value: " + String(genericGlider_mass_explicit.hull.sequence_start[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7501(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7501};
  modelica_boolean tmp687;
  modelica_boolean tmp688;
  static const MMC_DEFSTRINGLIT(tmp689,112,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.hull.sequence_start[1] <= 3, has value: ");
  modelica_string tmp690;
  static int tmp691 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp691)
  {
    tmp687 = GreaterEq(data->simulationInfo->integerParameter[62] /* genericGlider_mass_explicit.hull.sequence_start[1] PARAM */,((modelica_integer) 1));
    tmp688 = LessEq(data->simulationInfo->integerParameter[62] /* genericGlider_mass_explicit.hull.sequence_start[1] PARAM */,((modelica_integer) 3));
    if(!(tmp687 && tmp688))
    {
      tmp690 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[62] /* genericGlider_mass_explicit.hull.sequence_start[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp689),tmp690);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",678,5,680,63,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.sequence_start[1] >= 1 and genericGlider_mass_explicit.hull.sequence_start[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp691 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7502
type: ALGORITHM

  assert(genericGlider_mass_explicit.m_h >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.m_h, has value: " + String(genericGlider_mass_explicit.m_h, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7502(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7502};
  modelica_boolean tmp692;
  static const MMC_DEFSTRINGLIT(tmp693,86,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.m_h, has value: ");
  modelica_string tmp694;
  static int tmp695 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp695)
  {
    tmp692 = GreaterEq(data->simulationInfo->realParameter[479] /* genericGlider_mass_explicit.m_h PARAM */,0.0);
    if(!tmp692)
    {
      tmp694 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[479] /* genericGlider_mass_explicit.m_h PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp693),tmp694);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/GenericGlider_mass_explicit.mo",12,3,12,74,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.m_h >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp695 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7503
type: ALGORITHM

  assert(genericGlider_mass_explicit.hull.m >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.m, has value: " + String(genericGlider_mass_explicit.hull.m, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7503(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7503};
  modelica_boolean tmp696;
  static const MMC_DEFSTRINGLIT(tmp697,89,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.hull.m, has value: ");
  modelica_string tmp698;
  static int tmp699 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp699)
  {
    tmp696 = GreaterEq(data->simulationInfo->realParameter[424] /* genericGlider_mass_explicit.hull.m PARAM */,0.0);
    if(!tmp696)
    {
      tmp698 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[424] /* genericGlider_mass_explicit.hull.m PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp697),tmp698);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",637,5,637,61,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.hull.m >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp699 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7504
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7504(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7504};
  modelica_boolean tmp700;
  modelica_boolean tmp701;
  static const MMC_DEFSTRINGLIT(tmp702,258,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp703;
  static int tmp704 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp704)
  {
    tmp700 = GreaterEq(data->simulationInfo->integerParameter[57] /* genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame PARAM */,1);
    tmp701 = LessEq(data->simulationInfo->integerParameter[57] /* genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame PARAM */,3);
    if(!(tmp700 && tmp701))
    {
      tmp703 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[57] /* genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp702),tmp703);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",2733,7,2736,84,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.buoyancyForce.force.basicWorldForce.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp704 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7505
type: ALGORITHM

  assert(genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: " + String(genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7505(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7505};
  modelica_boolean tmp705;
  modelica_boolean tmp706;
  static const MMC_DEFSTRINGLIT(tmp707,242,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world <= genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve, has value: ");
  modelica_string tmp708;
  static int tmp709 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp709)
  {
    tmp705 = GreaterEq(data->simulationInfo->integerParameter[58] /* genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame PARAM */,1);
    tmp706 = LessEq(data->simulationInfo->integerParameter[58] /* genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame PARAM */,3);
    if(!(tmp705 && tmp706))
    {
      tmp708 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[58] /* genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp707),tmp708);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Forces.mo",20,5,22,88,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.buoyancyForce.force.resolveInFrame >= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world and genericGlider_mass_explicit.buoyancyForce.force.resolveInFrame <= Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp709 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7506
type: ALGORITHM

  assert(genericGlider_mass_explicit.absoluteAngles.sequence[3] >= 1 and genericGlider_mass_explicit.absoluteAngles.sequence[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.absoluteAngles.sequence[3] <= 3, has value: " + String(genericGlider_mass_explicit.absoluteAngles.sequence[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7506(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7506};
  modelica_boolean tmp710;
  modelica_boolean tmp711;
  static const MMC_DEFSTRINGLIT(tmp712,116,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.absoluteAngles.sequence[3] <= 3, has value: ");
  modelica_string tmp713;
  static int tmp714 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp714)
  {
    tmp710 = GreaterEq(data->simulationInfo->integerParameter[2] /* genericGlider_mass_explicit.absoluteAngles.sequence[3] PARAM */,((modelica_integer) 1));
    tmp711 = LessEq(data->simulationInfo->integerParameter[2] /* genericGlider_mass_explicit.absoluteAngles.sequence[3] PARAM */,((modelica_integer) 3));
    if(!(tmp710 && tmp711))
    {
      tmp713 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[2] /* genericGlider_mass_explicit.absoluteAngles.sequence[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp712),tmp713);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1132,5,1136,33,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.absoluteAngles.sequence[3] >= 1 and genericGlider_mass_explicit.absoluteAngles.sequence[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp714 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7507
type: ALGORITHM

  assert(genericGlider_mass_explicit.absoluteAngles.sequence[2] >= 1 and genericGlider_mass_explicit.absoluteAngles.sequence[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.absoluteAngles.sequence[2] <= 3, has value: " + String(genericGlider_mass_explicit.absoluteAngles.sequence[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7507(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7507};
  modelica_boolean tmp715;
  modelica_boolean tmp716;
  static const MMC_DEFSTRINGLIT(tmp717,116,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.absoluteAngles.sequence[2] <= 3, has value: ");
  modelica_string tmp718;
  static int tmp719 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp719)
  {
    tmp715 = GreaterEq(data->simulationInfo->integerParameter[1] /* genericGlider_mass_explicit.absoluteAngles.sequence[2] PARAM */,((modelica_integer) 1));
    tmp716 = LessEq(data->simulationInfo->integerParameter[1] /* genericGlider_mass_explicit.absoluteAngles.sequence[2] PARAM */,((modelica_integer) 3));
    if(!(tmp715 && tmp716))
    {
      tmp718 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[1] /* genericGlider_mass_explicit.absoluteAngles.sequence[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp717),tmp718);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1132,5,1136,33,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.absoluteAngles.sequence[2] >= 1 and genericGlider_mass_explicit.absoluteAngles.sequence[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp719 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7508
type: ALGORITHM

  assert(genericGlider_mass_explicit.absoluteAngles.sequence[1] >= 1 and genericGlider_mass_explicit.absoluteAngles.sequence[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.absoluteAngles.sequence[1] <= 3, has value: " + String(genericGlider_mass_explicit.absoluteAngles.sequence[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7508(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7508};
  modelica_boolean tmp720;
  modelica_boolean tmp721;
  static const MMC_DEFSTRINGLIT(tmp722,116,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.absoluteAngles.sequence[1] <= 3, has value: ");
  modelica_string tmp723;
  static int tmp724 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp724)
  {
    tmp720 = GreaterEq(data->simulationInfo->integerParameter[0] /* genericGlider_mass_explicit.absoluteAngles.sequence[1] PARAM */,((modelica_integer) 1));
    tmp721 = LessEq(data->simulationInfo->integerParameter[0] /* genericGlider_mass_explicit.absoluteAngles.sequence[1] PARAM */,((modelica_integer) 3));
    if(!(tmp720 && tmp721))
    {
      tmp723 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[0] /* genericGlider_mass_explicit.absoluteAngles.sequence[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp722),tmp723);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Sensors.mo",1132,5,1136,33,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.absoluteAngles.sequence[1] >= 1 and genericGlider_mass_explicit.absoluteAngles.sequence[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp724 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7509
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.limiter2.homotopyType >= Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy and genericGlider_mass_explicit.actuators.limiter2.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, "Variable violating min/max constraint: Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy <= genericGlider_mass_explicit.actuators.limiter2.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, has value: " + String(genericGlider_mass_explicit.actuators.limiter2.homotopyType, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7509(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7509};
  modelica_boolean tmp725;
  modelica_boolean tmp726;
  static const MMC_DEFSTRINGLIT(tmp727,215,"Variable violating min/max constraint: Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy <= genericGlider_mass_explicit.actuators.limiter2.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, has value: ");
  modelica_string tmp728;
  static int tmp729 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp729)
  {
    tmp725 = GreaterEq(data->simulationInfo->integerParameter[22] /* genericGlider_mass_explicit.actuators.limiter2.homotopyType PARAM */,1);
    tmp726 = LessEq(data->simulationInfo->integerParameter[22] /* genericGlider_mass_explicit.actuators.limiter2.homotopyType PARAM */,4);
    if(!(tmp725 && tmp726))
    {
      tmp728 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[22] /* genericGlider_mass_explicit.actuators.limiter2.homotopyType PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp727),tmp728);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Nonlinear.mo",12,9,13,69,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.limiter2.homotopyType >= Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy and genericGlider_mass_explicit.actuators.limiter2.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp729 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7510
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.limiter1.homotopyType >= Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy and genericGlider_mass_explicit.actuators.limiter1.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, "Variable violating min/max constraint: Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy <= genericGlider_mass_explicit.actuators.limiter1.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, has value: " + String(genericGlider_mass_explicit.actuators.limiter1.homotopyType, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7510(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7510};
  modelica_boolean tmp730;
  modelica_boolean tmp731;
  static const MMC_DEFSTRINGLIT(tmp732,215,"Variable violating min/max constraint: Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy <= genericGlider_mass_explicit.actuators.limiter1.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, has value: ");
  modelica_string tmp733;
  static int tmp734 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp734)
  {
    tmp730 = GreaterEq(data->simulationInfo->integerParameter[21] /* genericGlider_mass_explicit.actuators.limiter1.homotopyType PARAM */,1);
    tmp731 = LessEq(data->simulationInfo->integerParameter[21] /* genericGlider_mass_explicit.actuators.limiter1.homotopyType PARAM */,4);
    if(!(tmp730 && tmp731))
    {
      tmp733 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[21] /* genericGlider_mass_explicit.actuators.limiter1.homotopyType PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp732),tmp733);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Nonlinear.mo",12,9,13,69,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.limiter1.homotopyType >= Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy and genericGlider_mass_explicit.actuators.limiter1.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp734 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7511
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.limiter.homotopyType >= Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy and genericGlider_mass_explicit.actuators.limiter.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, "Variable violating min/max constraint: Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy <= genericGlider_mass_explicit.actuators.limiter.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, has value: " + String(genericGlider_mass_explicit.actuators.limiter.homotopyType, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7511(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7511};
  modelica_boolean tmp735;
  modelica_boolean tmp736;
  static const MMC_DEFSTRINGLIT(tmp737,214,"Variable violating min/max constraint: Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy <= genericGlider_mass_explicit.actuators.limiter.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit, has value: ");
  modelica_string tmp738;
  static int tmp739 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp739)
  {
    tmp735 = GreaterEq(data->simulationInfo->integerParameter[20] /* genericGlider_mass_explicit.actuators.limiter.homotopyType PARAM */,1);
    tmp736 = LessEq(data->simulationInfo->integerParameter[20] /* genericGlider_mass_explicit.actuators.limiter.homotopyType PARAM */,4);
    if(!(tmp735 && tmp736))
    {
      tmp738 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[20] /* genericGlider_mass_explicit.actuators.limiter.homotopyType PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp737),tmp738);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Nonlinear.mo",12,9,13,69,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.limiter.homotopyType >= Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy and genericGlider_mass_explicit.actuators.limiter.homotopyType <= Modelica.Blocks.Types.LimiterHomotopy.LowerLimit", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp739 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7512
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.I_33 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_33, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.I_33, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7512(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7512};
  modelica_boolean tmp740;
  static const MMC_DEFSTRINGLIT(tmp741,114,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_33, has value: ");
  modelica_string tmp742;
  static int tmp743 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp743)
  {
    tmp740 = GreaterEq(data->simulationInfo->realParameter[71] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_33 PARAM */,0.0);
    if(!tmp740)
    {
      tmp742 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[71] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_33 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp741),tmp742);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",19,3,20,132,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.I_33 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp743 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7513
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.I_32 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_32, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.I_32, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7513(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7513};
  modelica_boolean tmp744;
  static const MMC_DEFSTRINGLIT(tmp745,133,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_32, has value: ");
  modelica_string tmp746;
  static int tmp747 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp747)
  {
    tmp744 = GreaterEq(data->simulationInfo->realParameter[70] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_32 PARAM */,-9.999999999999999e+59);
    if(!tmp744)
    {
      tmp746 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[70] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_32 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp745),tmp746);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",25,3,26,132,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.I_32 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp747 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7514
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.I_31 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_31, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.I_31, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7514(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7514};
  modelica_boolean tmp748;
  static const MMC_DEFSTRINGLIT(tmp749,133,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_31, has value: ");
  modelica_string tmp750;
  static int tmp751 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp751)
  {
    tmp748 = GreaterEq(data->simulationInfo->realParameter[69] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_31 PARAM */,-9.999999999999999e+59);
    if(!tmp748)
    {
      tmp750 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[69] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_31 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp749),tmp750);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",23,3,24,132,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.I_31 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp751 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7515
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.I_22 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_22, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.I_22, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7515(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7515};
  modelica_boolean tmp752;
  static const MMC_DEFSTRINGLIT(tmp753,114,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_22, has value: ");
  modelica_string tmp754;
  static int tmp755 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp755)
  {
    tmp752 = GreaterEq(data->simulationInfo->realParameter[68] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_22 PARAM */,0.0);
    if(!tmp752)
    {
      tmp754 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[68] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_22 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp753),tmp754);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",17,3,18,132,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.I_22 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp755 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7516
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.I_21 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_21, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.I_21, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7516(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7516};
  modelica_boolean tmp756;
  static const MMC_DEFSTRINGLIT(tmp757,133,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_21, has value: ");
  modelica_string tmp758;
  static int tmp759 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp759)
  {
    tmp756 = GreaterEq(data->simulationInfo->realParameter[67] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_21 PARAM */,-9.999999999999999e+59);
    if(!tmp756)
    {
      tmp758 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[67] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_21 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp757),tmp758);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",21,3,22,132,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.I_21 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp759 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7517
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.I_11 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_11, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.I_11, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7517(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7517};
  modelica_boolean tmp760;
  static const MMC_DEFSTRINGLIT(tmp761,114,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.I_11, has value: ");
  modelica_string tmp762;
  static int tmp763 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp763)
  {
    tmp760 = GreaterEq(data->simulationInfo->realParameter[66] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_11 PARAM */,0.0);
    if(!tmp760)
    {
      tmp762 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[66] /* genericGlider_mass_explicit.actuators.bodyVariableMass.I_11 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp761),tmp762);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",15,3,16,132,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.I_11 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp763 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7518
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7518(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7518};
  modelica_boolean tmp764;
  modelica_boolean tmp765;
  static const MMC_DEFSTRINGLIT(tmp766,140,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] <= 3, has value: ");
  modelica_string tmp767;
  static int tmp768 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp768)
  {
    tmp764 = GreaterEq(data->simulationInfo->integerParameter[7] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] PARAM */,((modelica_integer) 1));
    tmp765 = LessEq(data->simulationInfo->integerParameter[7] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] PARAM */,((modelica_integer) 3));
    if(!(tmp764 && tmp765))
    {
      tmp767 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[7] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp766),tmp767);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",107,3,110,27,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp768 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7519
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7519(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7519};
  modelica_boolean tmp769;
  modelica_boolean tmp770;
  static const MMC_DEFSTRINGLIT(tmp771,140,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] <= 3, has value: ");
  modelica_string tmp772;
  static int tmp773 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp773)
  {
    tmp769 = GreaterEq(data->simulationInfo->integerParameter[6] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] PARAM */,((modelica_integer) 1));
    tmp770 = LessEq(data->simulationInfo->integerParameter[6] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] PARAM */,((modelica_integer) 3));
    if(!(tmp769 && tmp770))
    {
      tmp772 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[6] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp771),tmp772);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",107,3,110,27,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp773 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7520
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7520(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7520};
  modelica_boolean tmp774;
  modelica_boolean tmp775;
  static const MMC_DEFSTRINGLIT(tmp776,140,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] <= 3, has value: ");
  modelica_string tmp777;
  static int tmp778 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp778)
  {
    tmp774 = GreaterEq(data->simulationInfo->integerParameter[5] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] PARAM */,((modelica_integer) 1));
    tmp775 = LessEq(data->simulationInfo->integerParameter[5] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] PARAM */,((modelica_integer) 3));
    if(!(tmp774 && tmp775))
    {
      tmp777 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[5] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp776),tmp777);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",107,3,110,27,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_angleStates[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp778 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7521
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7521(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7521};
  modelica_boolean tmp779;
  static const MMC_DEFSTRINGLIT(tmp780,124,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter, has value: ");
  modelica_string tmp781;
  static int tmp782 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp782)
  {
    tmp779 = GreaterEq(data->simulationInfo->realParameter[99] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter PARAM */,0.0);
    if(!tmp779)
    {
      tmp781 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[99] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp780),tmp781);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",73,3,77,25,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sphereDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp782 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7522
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7522(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7522};
  modelica_boolean tmp783;
  static const MMC_DEFSTRINGLIT(tmp784,126,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter, has value: ");
  modelica_string tmp785;
  static int tmp786 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp786)
  {
    tmp783 = GreaterEq(data->simulationInfo->realParameter[91] /* genericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter PARAM */,0.0);
    if(!tmp783)
    {
      tmp785 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[91] /* genericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp784),tmp785);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",84,3,88,25,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.cylinderDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp786 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7523
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7523(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7523};
  modelica_boolean tmp787;
  modelica_boolean tmp788;
  static const MMC_DEFSTRINGLIT(tmp789,134,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] <= 3, has value: ");
  modelica_string tmp790;
  static int tmp791 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp791)
  {
    tmp787 = GreaterEq(data->simulationInfo->integerParameter[10] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] PARAM */,((modelica_integer) 1));
    tmp788 = LessEq(data->simulationInfo->integerParameter[10] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] PARAM */,((modelica_integer) 3));
    if(!(tmp787 && tmp788))
    {
      tmp790 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[10] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp789),tmp790);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",49,3,51,61,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp791 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7524
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7524(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7524};
  modelica_boolean tmp792;
  modelica_boolean tmp793;
  static const MMC_DEFSTRINGLIT(tmp794,134,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] <= 3, has value: ");
  modelica_string tmp795;
  static int tmp796 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp796)
  {
    tmp792 = GreaterEq(data->simulationInfo->integerParameter[9] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] PARAM */,((modelica_integer) 1));
    tmp793 = LessEq(data->simulationInfo->integerParameter[9] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] PARAM */,((modelica_integer) 3));
    if(!(tmp792 && tmp793))
    {
      tmp795 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[9] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp794),tmp795);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",49,3,51,61,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp796 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7525
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7525(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7525};
  modelica_boolean tmp797;
  modelica_boolean tmp798;
  static const MMC_DEFSTRINGLIT(tmp799,134,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] <= 3, has value: ");
  modelica_string tmp800;
  static int tmp801 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp801)
  {
    tmp797 = GreaterEq(data->simulationInfo->integerParameter[8] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] PARAM */,((modelica_integer) 1));
    tmp798 = LessEq(data->simulationInfo->integerParameter[8] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] PARAM */,((modelica_integer) 3));
    if(!(tmp797 && tmp798))
    {
      tmp800 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[8] /* genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp799),tmp800);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/BodyVariableMass.mo",49,3,51,61,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] >= 1 and genericGlider_mass_explicit.actuators.bodyVariableMass.sequence_start[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp801 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7526
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.static_translation_VBD.height >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.height, has value: " + String(genericGlider_mass_explicit.actuators.static_translation_VBD.height, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7526(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7526};
  modelica_boolean tmp802;
  static const MMC_DEFSTRINGLIT(tmp803,122,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.height, has value: ");
  modelica_string tmp804;
  static int tmp805 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp805)
  {
    tmp802 = GreaterEq(data->simulationInfo->realParameter[281] /* genericGlider_mass_explicit.actuators.static_translation_VBD.height PARAM */,0.0);
    if(!tmp802)
    {
      tmp804 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[281] /* genericGlider_mass_explicit.actuators.static_translation_VBD.height PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp803),tmp804);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",191,5,194,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.static_translation_VBD.height >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp805 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7527
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.static_translation_VBD.width >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.width, has value: " + String(genericGlider_mass_explicit.actuators.static_translation_VBD.width, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7527(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7527};
  modelica_boolean tmp806;
  static const MMC_DEFSTRINGLIT(tmp807,121,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.static_translation_VBD.width, has value: ");
  modelica_string tmp808;
  static int tmp809 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp809)
  {
    tmp806 = GreaterEq(data->simulationInfo->realParameter[295] /* genericGlider_mass_explicit.actuators.static_translation_VBD.width PARAM */,0.0);
    if(!tmp806)
    {
      tmp808 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[295] /* genericGlider_mass_explicit.actuators.static_translation_VBD.width PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp807),tmp808);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",186,5,190,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.static_translation_VBD.width >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp809 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7528
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7528(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7528};
  modelica_boolean tmp810;
  static const MMC_DEFSTRINGLIT(tmp811,128,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height, has value: ");
  modelica_string tmp812;
  static int tmp813 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp813)
  {
    tmp810 = GreaterEq(data->simulationInfo->realParameter[201] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height PARAM */,0.0);
    if(!tmp810)
    {
      tmp812 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[201] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp811),tmp812);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",191,5,194,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.height >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp813 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7529
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width, has value: " + String(genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7529(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7529};
  modelica_boolean tmp814;
  static const MMC_DEFSTRINGLIT(tmp815,127,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width, has value: ");
  modelica_string tmp816;
  static int tmp817 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp817)
  {
    tmp814 = GreaterEq(data->simulationInfo->realParameter[215] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width PARAM */,0.0);
    if(!tmp814)
    {
      tmp816 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[215] /* genericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp815),tmp816);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",186,5,190,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.fixedTranslation_pendulumArm.width >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp817 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7530
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.prismatic.stateSelect >= StateSelect.never and genericGlider_mass_explicit.actuators.prismatic.stateSelect <= StateSelect.always, "Variable violating min/max constraint: StateSelect.never <= genericGlider_mass_explicit.actuators.prismatic.stateSelect <= StateSelect.always, has value: " + String(genericGlider_mass_explicit.actuators.prismatic.stateSelect, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7530(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7530};
  modelica_boolean tmp818;
  modelica_boolean tmp819;
  static const MMC_DEFSTRINGLIT(tmp820,154,"Variable violating min/max constraint: StateSelect.never <= genericGlider_mass_explicit.actuators.prismatic.stateSelect <= StateSelect.always, has value: ");
  modelica_string tmp821;
  static int tmp822 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp822)
  {
    tmp818 = GreaterEq(data->simulationInfo->integerParameter[23] /* genericGlider_mass_explicit.actuators.prismatic.stateSelect PARAM */,1);
    tmp819 = LessEq(data->simulationInfo->integerParameter[23] /* genericGlider_mass_explicit.actuators.prismatic.stateSelect PARAM */,5);
    if(!(tmp818 && tmp819))
    {
      tmp821 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[23] /* genericGlider_mass_explicit.actuators.prismatic.stateSelect PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp820),tmp821);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",39,5,40,93,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.prismatic.stateSelect >= StateSelect.never and genericGlider_mass_explicit.actuators.prismatic.stateSelect <= StateSelect.always", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp822 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7531
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.revolute.stateSelect >= StateSelect.never and genericGlider_mass_explicit.actuators.revolute.stateSelect <= StateSelect.always, "Variable violating min/max constraint: StateSelect.never <= genericGlider_mass_explicit.actuators.revolute.stateSelect <= StateSelect.always, has value: " + String(genericGlider_mass_explicit.actuators.revolute.stateSelect, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7531(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7531};
  modelica_boolean tmp823;
  modelica_boolean tmp824;
  static const MMC_DEFSTRINGLIT(tmp825,153,"Variable violating min/max constraint: StateSelect.never <= genericGlider_mass_explicit.actuators.revolute.stateSelect <= StateSelect.always, has value: ");
  modelica_string tmp826;
  static int tmp827 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp827)
  {
    tmp823 = GreaterEq(data->simulationInfo->integerParameter[24] /* genericGlider_mass_explicit.actuators.revolute.stateSelect PARAM */,1);
    tmp824 = LessEq(data->simulationInfo->integerParameter[24] /* genericGlider_mass_explicit.actuators.revolute.stateSelect PARAM */,5);
    if(!(tmp823 && tmp824))
    {
      tmp826 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[24] /* genericGlider_mass_explicit.actuators.revolute.stateSelect PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp825),tmp826);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Joints.mo",242,5,243,100,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.revolute.stateSelect >= StateSelect.never and genericGlider_mass_explicit.actuators.revolute.stateSelect <= StateSelect.always", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp827 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7532
type: ALGORITHM

  assert(genericGlider_mass_explicit.m_r >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.m_r, has value: " + String(genericGlider_mass_explicit.m_r, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7532(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7532};
  modelica_boolean tmp828;
  static const MMC_DEFSTRINGLIT(tmp829,86,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.m_r, has value: ");
  modelica_string tmp830;
  static int tmp831 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp831)
  {
    tmp828 = GreaterEq(data->simulationInfo->realParameter[480] /* genericGlider_mass_explicit.m_r PARAM */,0.0);
    if(!tmp828)
    {
      tmp830 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[480] /* genericGlider_mass_explicit.m_r PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp829),tmp830);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/GenericGlider_mass_explicit.mo",13,3,13,68,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.m_r >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp831 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7533
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.m_r >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.m_r, has value: " + String(genericGlider_mass_explicit.actuators.m_r, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7533(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7533};
  modelica_boolean tmp832;
  static const MMC_DEFSTRINGLIT(tmp833,96,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.m_r, has value: ");
  modelica_string tmp834;
  static int tmp835 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp835)
  {
    tmp832 = GreaterEq(data->simulationInfo->realParameter[225] /* genericGlider_mass_explicit.actuators.m_r PARAM */,0.0);
    if(!tmp832)
    {
      tmp834 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[225] /* genericGlider_mass_explicit.actuators.m_r PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp833),tmp834);
      {
        FILE_INFO info = {"/home/automata/repos/Glider_Lib_Modelica_ROS/Actuators.mo",13,3,13,61,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.m_r >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp835 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7534
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.I_33 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.I_33, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.I_33, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7534(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7534};
  modelica_boolean tmp836;
  static const MMC_DEFSTRINGLIT(tmp837,110,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.I_33, has value: ");
  modelica_string tmp838;
  static int tmp839 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp839)
  {
    tmp836 = GreaterEq(data->simulationInfo->realParameter[123] /* genericGlider_mass_explicit.actuators.body_rolling.I_33 PARAM */,0.0);
    if(!tmp836)
    {
      tmp838 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[123] /* genericGlider_mass_explicit.actuators.body_rolling.I_33 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp837),tmp838);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",644,5,646,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.I_33 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp839 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7535
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.I_32 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.body_rolling.I_32, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.I_32, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7535(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7535};
  modelica_boolean tmp840;
  static const MMC_DEFSTRINGLIT(tmp841,129,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.body_rolling.I_32, has value: ");
  modelica_string tmp842;
  static int tmp843 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp843)
  {
    tmp840 = GreaterEq(data->simulationInfo->realParameter[122] /* genericGlider_mass_explicit.actuators.body_rolling.I_32 PARAM */,-9.999999999999999e+59);
    if(!tmp840)
    {
      tmp842 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[122] /* genericGlider_mass_explicit.actuators.body_rolling.I_32 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp841),tmp842);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",653,5,655,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.I_32 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp843 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7536
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.I_31 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.body_rolling.I_31, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.I_31, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7536(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7536};
  modelica_boolean tmp844;
  static const MMC_DEFSTRINGLIT(tmp845,129,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.body_rolling.I_31, has value: ");
  modelica_string tmp846;
  static int tmp847 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp847)
  {
    tmp844 = GreaterEq(data->simulationInfo->realParameter[121] /* genericGlider_mass_explicit.actuators.body_rolling.I_31 PARAM */,-9.999999999999999e+59);
    if(!tmp844)
    {
      tmp846 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[121] /* genericGlider_mass_explicit.actuators.body_rolling.I_31 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp845),tmp846);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",650,5,652,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.I_31 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp847 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7537
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.I_22 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.I_22, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.I_22, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7537(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7537};
  modelica_boolean tmp848;
  static const MMC_DEFSTRINGLIT(tmp849,110,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.I_22, has value: ");
  modelica_string tmp850;
  static int tmp851 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp851)
  {
    tmp848 = GreaterEq(data->simulationInfo->realParameter[120] /* genericGlider_mass_explicit.actuators.body_rolling.I_22 PARAM */,0.0);
    if(!tmp848)
    {
      tmp850 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[120] /* genericGlider_mass_explicit.actuators.body_rolling.I_22 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp849),tmp850);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",641,5,643,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.I_22 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp851 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7538
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.I_21 >= -9.999999999999999e+59, "Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.body_rolling.I_21, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.I_21, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7538(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7538};
  modelica_boolean tmp852;
  static const MMC_DEFSTRINGLIT(tmp853,129,"Variable violating min constraint: -9.999999999999999e+59 <= genericGlider_mass_explicit.actuators.body_rolling.I_21, has value: ");
  modelica_string tmp854;
  static int tmp855 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp855)
  {
    tmp852 = GreaterEq(data->simulationInfo->realParameter[119] /* genericGlider_mass_explicit.actuators.body_rolling.I_21 PARAM */,-9.999999999999999e+59);
    if(!tmp852)
    {
      tmp854 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[119] /* genericGlider_mass_explicit.actuators.body_rolling.I_21 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp853),tmp854);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",647,5,649,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.I_21 >= -9.999999999999999e+59", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp855 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7539
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.I_11 >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.I_11, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.I_11, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7539(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7539};
  modelica_boolean tmp856;
  static const MMC_DEFSTRINGLIT(tmp857,110,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.I_11, has value: ");
  modelica_string tmp858;
  static int tmp859 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp859)
  {
    tmp856 = GreaterEq(data->simulationInfo->realParameter[118] /* genericGlider_mass_explicit.actuators.body_rolling.I_11 PARAM */,0.0);
    if(!tmp856)
    {
      tmp858 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[118] /* genericGlider_mass_explicit.actuators.body_rolling.I_11 PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp857),tmp858);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",638,5,640,81,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.I_11 >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp859 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7540
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7540(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7540};
  modelica_boolean tmp860;
  modelica_boolean tmp861;
  static const MMC_DEFSTRINGLIT(tmp862,136,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] <= 3, has value: ");
  modelica_string tmp863;
  static int tmp864 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp864)
  {
    tmp860 = GreaterEq(data->simulationInfo->integerParameter[13] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] PARAM */,((modelica_integer) 1));
    tmp861 = LessEq(data->simulationInfo->integerParameter[13] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] PARAM */,((modelica_integer) 3));
    if(!(tmp860 && tmp861))
    {
      tmp863 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[13] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp862),tmp863);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",736,5,739,29,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp864 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7541
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7541(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7541};
  modelica_boolean tmp865;
  modelica_boolean tmp866;
  static const MMC_DEFSTRINGLIT(tmp867,136,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] <= 3, has value: ");
  modelica_string tmp868;
  static int tmp869 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp869)
  {
    tmp865 = GreaterEq(data->simulationInfo->integerParameter[12] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] PARAM */,((modelica_integer) 1));
    tmp866 = LessEq(data->simulationInfo->integerParameter[12] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] PARAM */,((modelica_integer) 3));
    if(!(tmp865 && tmp866))
    {
      tmp868 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[12] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp867),tmp868);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",736,5,739,29,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp869 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7542
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7542(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7542};
  modelica_boolean tmp870;
  modelica_boolean tmp871;
  static const MMC_DEFSTRINGLIT(tmp872,136,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] <= 3, has value: ");
  modelica_string tmp873;
  static int tmp874 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp874)
  {
    tmp870 = GreaterEq(data->simulationInfo->integerParameter[11] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] PARAM */,((modelica_integer) 1));
    tmp871 = LessEq(data->simulationInfo->integerParameter[11] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] PARAM */,((modelica_integer) 3));
    if(!(tmp870 && tmp871))
    {
      tmp873 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[11] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp872),tmp873);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",736,5,739,29,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_angleStates[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp874 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7543
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sphereDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.sphereDiameter, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sphereDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7543(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7543};
  modelica_boolean tmp875;
  static const MMC_DEFSTRINGLIT(tmp876,120,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.sphereDiameter, has value: ");
  modelica_string tmp877;
  static int tmp878 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp878)
  {
    tmp875 = GreaterEq(data->simulationInfo->realParameter[152] /* genericGlider_mass_explicit.actuators.body_rolling.sphereDiameter PARAM */,0.0);
    if(!tmp875)
    {
      tmp877 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[152] /* genericGlider_mass_explicit.actuators.body_rolling.sphereDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp876),tmp877);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",702,5,706,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sphereDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp878 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7544
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7544(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7544};
  modelica_boolean tmp879;
  static const MMC_DEFSTRINGLIT(tmp880,122,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter, has value: ");
  modelica_string tmp881;
  static int tmp882 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp882)
  {
    tmp879 = GreaterEq(data->simulationInfo->realParameter[143] /* genericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter PARAM */,0.0);
    if(!tmp879)
    {
      tmp881 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[143] /* genericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp880),tmp881);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",713,5,717,27,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.cylinderDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp882 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7545
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7545(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7545};
  modelica_boolean tmp883;
  modelica_boolean tmp884;
  static const MMC_DEFSTRINGLIT(tmp885,130,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] <= 3, has value: ");
  modelica_string tmp886;
  static int tmp887 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp887)
  {
    tmp883 = GreaterEq(data->simulationInfo->integerParameter[16] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] PARAM */,((modelica_integer) 1));
    tmp884 = LessEq(data->simulationInfo->integerParameter[16] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] PARAM */,((modelica_integer) 3));
    if(!(tmp883 && tmp884))
    {
      tmp886 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[16] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp885),tmp886);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",678,5,680,63,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_start[3] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp887 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7546
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7546(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7546};
  modelica_boolean tmp888;
  modelica_boolean tmp889;
  static const MMC_DEFSTRINGLIT(tmp890,130,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] <= 3, has value: ");
  modelica_string tmp891;
  static int tmp892 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp892)
  {
    tmp888 = GreaterEq(data->simulationInfo->integerParameter[15] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] PARAM */,((modelica_integer) 1));
    tmp889 = LessEq(data->simulationInfo->integerParameter[15] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] PARAM */,((modelica_integer) 3));
    if(!(tmp888 && tmp889))
    {
      tmp891 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[15] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp890),tmp891);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",678,5,680,63,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_start[2] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp892 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7547
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] <= 3, "Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] <= 3, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1], "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7547(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7547};
  modelica_boolean tmp893;
  modelica_boolean tmp894;
  static const MMC_DEFSTRINGLIT(tmp895,130,"Variable violating min/max constraint: 1 <= genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] <= 3, has value: ");
  modelica_string tmp896;
  static int tmp897 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp897)
  {
    tmp893 = GreaterEq(data->simulationInfo->integerParameter[14] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] PARAM */,((modelica_integer) 1));
    tmp894 = LessEq(data->simulationInfo->integerParameter[14] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] PARAM */,((modelica_integer) 3));
    if(!(tmp893 && tmp894))
    {
      tmp896 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[14] /* genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp895),tmp896);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",678,5,680,63,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] >= 1 and genericGlider_mass_explicit.actuators.body_rolling.sequence_start[1] <= 3", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp897 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7548
type: ALGORITHM

  assert(genericGlider_mass_explicit.actuators.body_rolling.m >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.m, has value: " + String(genericGlider_mass_explicit.actuators.body_rolling.m, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7548(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7548};
  modelica_boolean tmp898;
  static const MMC_DEFSTRINGLIT(tmp899,107,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.actuators.body_rolling.m, has value: ");
  modelica_string tmp900;
  static int tmp901 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp901)
  {
    tmp898 = GreaterEq(data->simulationInfo->realParameter[144] /* genericGlider_mass_explicit.actuators.body_rolling.m PARAM */,0.0);
    if(!tmp898)
    {
      tmp900 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[144] /* genericGlider_mass_explicit.actuators.body_rolling.m PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp899),tmp900);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/Parts.mo",637,5,637,61,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.actuators.body_rolling.m >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp901 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7549
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.gravitySphereDiameter >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.gravitySphereDiameter, has value: " + String(genericGlider_mass_explicit.world.gravitySphereDiameter, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7549(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7549};
  modelica_boolean tmp902;
  static const MMC_DEFSTRINGLIT(tmp903,110,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.gravitySphereDiameter, has value: ");
  modelica_string tmp904;
  static int tmp905 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp905)
  {
    tmp902 = GreaterEq(data->simulationInfo->realParameter[541] /* genericGlider_mass_explicit.world.gravitySphereDiameter PARAM */,0.0);
    if(!tmp902)
    {
      tmp904 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[541] /* genericGlider_mass_explicit.world.gravitySphereDiameter PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp903),tmp904);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1116,3,1120,99,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.gravitySphereDiameter >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp905 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7550
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.mue >= 0.0, "Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.mue, has value: " + String(genericGlider_mass_explicit.world.mue, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7550(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7550};
  modelica_boolean tmp906;
  static const MMC_DEFSTRINGLIT(tmp907,92,"Variable violating min constraint: 0.0 <= genericGlider_mass_explicit.world.mue, has value: ");
  modelica_string tmp908;
  static int tmp909 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp909)
  {
    tmp906 = GreaterEq(data->simulationInfo->realParameter[552] /* genericGlider_mass_explicit.world.mue PARAM */,0.0);
    if(!tmp906)
    {
      tmp908 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[552] /* genericGlider_mass_explicit.world.mue PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp907),tmp908);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1074,3,1078,108,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.mue >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp909 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7551
type: ALGORITHM

  assert(genericGlider_mass_explicit.world.gravityType >= Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity and genericGlider_mass_explicit.world.gravityType <= Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity, "Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity <= genericGlider_mass_explicit.world.gravityType <= Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity, has value: " + String(genericGlider_mass_explicit.world.gravityType, "d"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7551(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7551};
  modelica_boolean tmp910;
  modelica_boolean tmp911;
  static const MMC_DEFSTRINGLIT(tmp912,222,"Variable violating min/max constraint: Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity <= genericGlider_mass_explicit.world.gravityType <= Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity, has value: ");
  modelica_string tmp913;
  static int tmp914 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp914)
  {
    tmp910 = GreaterEq(data->simulationInfo->integerParameter[80] /* genericGlider_mass_explicit.world.gravityType PARAM */,1);
    tmp911 = LessEq(data->simulationInfo->integerParameter[80] /* genericGlider_mass_explicit.world.gravityType PARAM */,3);
    if(!(tmp910 && tmp911))
    {
      tmp913 = modelica_integer_to_modelica_string_format(data->simulationInfo->integerParameter[80] /* genericGlider_mass_explicit.world.gravityType PARAM */, (modelica_string) mmc_strings_len1[100]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp912),tmp913);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Mechanics/MultiBody/package.mo",1067,3,1068,54,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ngenericGlider_mass_explicit.world.gravityType >= Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity and genericGlider_mass_explicit.world.gravityType <= Modelica.Mechanics.MultiBody.Types.GravityTypes.PointGravity", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp914 = 1;
    }
  }
  TRACE_POP
}

/*
equation index: 7552
type: ALGORITHM

  assert(rotating_mass_pos.duration >= 0.0, "Variable violating min constraint: 0.0 <= rotating_mass_pos.duration, has value: " + String(rotating_mass_pos.duration, "g"));
*/
OMC_DISABLE_OPT
static void TestGlider_eqFunction_7552(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7552};
  modelica_boolean tmp915;
  static const MMC_DEFSTRINGLIT(tmp916,81,"Variable violating min constraint: 0.0 <= rotating_mass_pos.duration, has value: ");
  modelica_string tmp917;
  static int tmp918 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp918)
  {
    tmp915 = GreaterEq(data->simulationInfo->realParameter[646] /* rotating_mass_pos.duration PARAM */,0.0);
    if(!tmp915)
    {
      tmp917 = modelica_real_to_modelica_string_format(data->simulationInfo->realParameter[646] /* rotating_mass_pos.duration PARAM */, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp916),tmp917);
      {
        FILE_INFO info = {"/usr/lib/omlibrary/Modelica 3.2.3/Blocks/Sources.mo",388,5,389,46,1};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nrotating_mass_pos.duration >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp918 = 1;
    }
  }
  TRACE_POP
}
OMC_DISABLE_OPT
void TestGlider_updateBoundParameters_1(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  TestGlider_eqFunction_877(data, threadData);
  TestGlider_eqFunction_876(data, threadData);
  TestGlider_eqFunction_875(data, threadData);
  TestGlider_eqFunction_874(data, threadData);
  TestGlider_eqFunction_873(data, threadData);
  TestGlider_eqFunction_872(data, threadData);
  TestGlider_eqFunction_871(data, threadData);
  TestGlider_eqFunction_870(data, threadData);
  TestGlider_eqFunction_869(data, threadData);
  TestGlider_eqFunction_867(data, threadData);
  TestGlider_eqFunction_865(data, threadData);
  TestGlider_eqFunction_864(data, threadData);
  TestGlider_eqFunction_863(data, threadData);
  TestGlider_eqFunction_862(data, threadData);
  TestGlider_eqFunction_861(data, threadData);
  TestGlider_eqFunction_860(data, threadData);
  TestGlider_eqFunction_859(data, threadData);
  TestGlider_eqFunction_858(data, threadData);
  TestGlider_eqFunction_857(data, threadData);
  TestGlider_eqFunction_856(data, threadData);
  TestGlider_eqFunction_855(data, threadData);
  TestGlider_eqFunction_854(data, threadData);
  TestGlider_eqFunction_853(data, threadData);
  TestGlider_eqFunction_852(data, threadData);
  TestGlider_eqFunction_850(data, threadData);
  TestGlider_eqFunction_848(data, threadData);
  TestGlider_eqFunction_847(data, threadData);
  TestGlider_eqFunction_846(data, threadData);
  TestGlider_eqFunction_845(data, threadData);
  TestGlider_eqFunction_844(data, threadData);
  TestGlider_eqFunction_843(data, threadData);
  TestGlider_eqFunction_842(data, threadData);
  TestGlider_eqFunction_841(data, threadData);
  TestGlider_eqFunction_840(data, threadData);
  TestGlider_eqFunction_839(data, threadData);
  TestGlider_eqFunction_838(data, threadData);
  TestGlider_eqFunction_837(data, threadData);
  TestGlider_eqFunction_836(data, threadData);
  TestGlider_eqFunction_835(data, threadData);
  TestGlider_eqFunction_834(data, threadData);
  TestGlider_eqFunction_833(data, threadData);
  TestGlider_eqFunction_832(data, threadData);
  TestGlider_eqFunction_831(data, threadData);
  TestGlider_eqFunction_830(data, threadData);
  TestGlider_eqFunction_829(data, threadData);
  TestGlider_eqFunction_828(data, threadData);
  TestGlider_eqFunction_827(data, threadData);
  TestGlider_eqFunction_826(data, threadData);
  TestGlider_eqFunction_825(data, threadData);
  TestGlider_eqFunction_824(data, threadData);
  TestGlider_eqFunction_823(data, threadData);
  TestGlider_eqFunction_822(data, threadData);
  TestGlider_eqFunction_821(data, threadData);
  TestGlider_eqFunction_820(data, threadData);
  TestGlider_eqFunction_819(data, threadData);
  TestGlider_eqFunction_818(data, threadData);
  TestGlider_eqFunction_817(data, threadData);
  TestGlider_eqFunction_816(data, threadData);
  TestGlider_eqFunction_815(data, threadData);
  TestGlider_eqFunction_814(data, threadData);
  TestGlider_eqFunction_813(data, threadData);
  TestGlider_eqFunction_812(data, threadData);
  TestGlider_eqFunction_811(data, threadData);
  TestGlider_eqFunction_810(data, threadData);
  TestGlider_eqFunction_809(data, threadData);
  TestGlider_eqFunction_808(data, threadData);
  TestGlider_eqFunction_807(data, threadData);
  TestGlider_eqFunction_806(data, threadData);
  TestGlider_eqFunction_805(data, threadData);
  TestGlider_eqFunction_804(data, threadData);
  TestGlider_eqFunction_803(data, threadData);
  TestGlider_eqFunction_802(data, threadData);
  TestGlider_eqFunction_801(data, threadData);
  TestGlider_eqFunction_799(data, threadData);
  TestGlider_eqFunction_798(data, threadData);
  TestGlider_eqFunction_797(data, threadData);
  TestGlider_eqFunction_796(data, threadData);
  TestGlider_eqFunction_795(data, threadData);
  TestGlider_eqFunction_794(data, threadData);
  TestGlider_eqFunction_793(data, threadData);
  TestGlider_eqFunction_792(data, threadData);
  TestGlider_eqFunction_791(data, threadData);
  TestGlider_eqFunction_790(data, threadData);
  TestGlider_eqFunction_789(data, threadData);
  TestGlider_eqFunction_788(data, threadData);
  TestGlider_eqFunction_787(data, threadData);
  TestGlider_eqFunction_786(data, threadData);
  TestGlider_eqFunction_785(data, threadData);
  TestGlider_eqFunction_784(data, threadData);
  TestGlider_eqFunction_783(data, threadData);
  TestGlider_eqFunction_782(data, threadData);
  TestGlider_eqFunction_781(data, threadData);
  TestGlider_eqFunction_780(data, threadData);
  TestGlider_eqFunction_779(data, threadData);
  TestGlider_eqFunction_778(data, threadData);
  TestGlider_eqFunction_777(data, threadData);
  TestGlider_eqFunction_776(data, threadData);
  TestGlider_eqFunction_775(data, threadData);
  TestGlider_eqFunction_774(data, threadData);
  TestGlider_eqFunction_773(data, threadData);
  TestGlider_eqFunction_772(data, threadData);
  TestGlider_eqFunction_771(data, threadData);
  TestGlider_eqFunction_770(data, threadData);
  TestGlider_eqFunction_769(data, threadData);
  TestGlider_eqFunction_768(data, threadData);
  TestGlider_eqFunction_767(data, threadData);
  TestGlider_eqFunction_766(data, threadData);
  TestGlider_eqFunction_765(data, threadData);
  TestGlider_eqFunction_764(data, threadData);
  TestGlider_eqFunction_763(data, threadData);
  TestGlider_eqFunction_762(data, threadData);
  TestGlider_eqFunction_761(data, threadData);
  TestGlider_eqFunction_760(data, threadData);
  TestGlider_eqFunction_759(data, threadData);
  TestGlider_eqFunction_758(data, threadData);
  TestGlider_eqFunction_757(data, threadData);
  TestGlider_eqFunction_755(data, threadData);
  TestGlider_eqFunction_753(data, threadData);
  TestGlider_eqFunction_752(data, threadData);
  TestGlider_eqFunction_751(data, threadData);
  TestGlider_eqFunction_750(data, threadData);
  TestGlider_eqFunction_749(data, threadData);
  TestGlider_eqFunction_748(data, threadData);
  TestGlider_eqFunction_747(data, threadData);
  TestGlider_eqFunction_746(data, threadData);
  TestGlider_eqFunction_745(data, threadData);
  TestGlider_eqFunction_744(data, threadData);
  TestGlider_eqFunction_743(data, threadData);
  TestGlider_eqFunction_742(data, threadData);
  TestGlider_eqFunction_741(data, threadData);
  TestGlider_eqFunction_740(data, threadData);
  TestGlider_eqFunction_739(data, threadData);
  TestGlider_eqFunction_738(data, threadData);
  TestGlider_eqFunction_737(data, threadData);
  TestGlider_eqFunction_736(data, threadData);
  TestGlider_eqFunction_735(data, threadData);
  TestGlider_eqFunction_734(data, threadData);
  TestGlider_eqFunction_733(data, threadData);
  TestGlider_eqFunction_732(data, threadData);
  TestGlider_eqFunction_731(data, threadData);
  TestGlider_eqFunction_730(data, threadData);
  TestGlider_eqFunction_729(data, threadData);
  TestGlider_eqFunction_728(data, threadData);
  TestGlider_eqFunction_727(data, threadData);
  TestGlider_eqFunction_726(data, threadData);
  TestGlider_eqFunction_725(data, threadData);
  TestGlider_eqFunction_723(data, threadData);
  TestGlider_eqFunction_720(data, threadData);
  TestGlider_eqFunction_719(data, threadData);
  TestGlider_eqFunction_718(data, threadData);
  TestGlider_eqFunction_717(data, threadData);
  TestGlider_eqFunction_716(data, threadData);
  TestGlider_eqFunction_715(data, threadData);
  TestGlider_eqFunction_714(data, threadData);
  TestGlider_eqFunction_713(data, threadData);
  TestGlider_eqFunction_712(data, threadData);
  TestGlider_eqFunction_711(data, threadData);
  TestGlider_eqFunction_710(data, threadData);
  TestGlider_eqFunction_709(data, threadData);
  TestGlider_eqFunction_708(data, threadData);
  TestGlider_eqFunction_707(data, threadData);
  TestGlider_eqFunction_706(data, threadData);
  TestGlider_eqFunction_705(data, threadData);
  TestGlider_eqFunction_704(data, threadData);
  TestGlider_eqFunction_703(data, threadData);
  TestGlider_eqFunction_700(data, threadData);
  TestGlider_eqFunction_699(data, threadData);
  TestGlider_eqFunction_698(data, threadData);
  TestGlider_eqFunction_697(data, threadData);
  TestGlider_eqFunction_696(data, threadData);
  TestGlider_eqFunction_695(data, threadData);
  TestGlider_eqFunction_694(data, threadData);
  TestGlider_eqFunction_693(data, threadData);
  TestGlider_eqFunction_692(data, threadData);
  TestGlider_eqFunction_691(data, threadData);
  TestGlider_eqFunction_690(data, threadData);
  TestGlider_eqFunction_689(data, threadData);
  TestGlider_eqFunction_688(data, threadData);
  TestGlider_eqFunction_687(data, threadData);
  TestGlider_eqFunction_686(data, threadData);
  TestGlider_eqFunction_685(data, threadData);
  TestGlider_eqFunction_684(data, threadData);
  TestGlider_eqFunction_683(data, threadData);
  TestGlider_eqFunction_682(data, threadData);
  TestGlider_eqFunction_681(data, threadData);
  TestGlider_eqFunction_680(data, threadData);
  TestGlider_eqFunction_679(data, threadData);
  TestGlider_eqFunction_678(data, threadData);
  TestGlider_eqFunction_677(data, threadData);
  TestGlider_eqFunction_676(data, threadData);
  TestGlider_eqFunction_672(data, threadData);
  TestGlider_eqFunction_671(data, threadData);
  TestGlider_eqFunction_670(data, threadData);
  TestGlider_eqFunction_669(data, threadData);
  TestGlider_eqFunction_668(data, threadData);
  TestGlider_eqFunction_667(data, threadData);
  TestGlider_eqFunction_666(data, threadData);
  TestGlider_eqFunction_665(data, threadData);
  TestGlider_eqFunction_664(data, threadData);
  TestGlider_eqFunction_663(data, threadData);
  TestGlider_eqFunction_662(data, threadData);
  TestGlider_eqFunction_661(data, threadData);
  TestGlider_eqFunction_660(data, threadData);
  TestGlider_eqFunction_659(data, threadData);
  TestGlider_eqFunction_658(data, threadData);
  TestGlider_eqFunction_657(data, threadData);
  TestGlider_eqFunction_656(data, threadData);
  TestGlider_eqFunction_655(data, threadData);
  TestGlider_eqFunction_654(data, threadData);
  TestGlider_eqFunction_653(data, threadData);
  TestGlider_eqFunction_652(data, threadData);
  TestGlider_eqFunction_651(data, threadData);
  TestGlider_eqFunction_650(data, threadData);
  TestGlider_eqFunction_649(data, threadData);
  TestGlider_eqFunction_648(data, threadData);
  TestGlider_eqFunction_647(data, threadData);
  TestGlider_eqFunction_646(data, threadData);
  TestGlider_eqFunction_645(data, threadData);
  TestGlider_eqFunction_644(data, threadData);
  TestGlider_eqFunction_643(data, threadData);
  TestGlider_eqFunction_642(data, threadData);
  TestGlider_eqFunction_641(data, threadData);
  TestGlider_eqFunction_640(data, threadData);
  TestGlider_eqFunction_639(data, threadData);
  TestGlider_eqFunction_638(data, threadData);
  TestGlider_eqFunction_636(data, threadData);
  TestGlider_eqFunction_634(data, threadData);
  TestGlider_eqFunction_633(data, threadData);
  TestGlider_eqFunction_632(data, threadData);
  TestGlider_eqFunction_631(data, threadData);
  TestGlider_eqFunction_630(data, threadData);
  TestGlider_eqFunction_629(data, threadData);
  TestGlider_eqFunction_628(data, threadData);
  TestGlider_eqFunction_627(data, threadData);
  TestGlider_eqFunction_626(data, threadData);
  TestGlider_eqFunction_625(data, threadData);
  TestGlider_eqFunction_624(data, threadData);
  TestGlider_eqFunction_623(data, threadData);
  TestGlider_eqFunction_622(data, threadData);
  TestGlider_eqFunction_621(data, threadData);
  TestGlider_eqFunction_620(data, threadData);
  TestGlider_eqFunction_619(data, threadData);
  TestGlider_eqFunction_615(data, threadData);
  TestGlider_eqFunction_614(data, threadData);
  TestGlider_eqFunction_613(data, threadData);
  TestGlider_eqFunction_612(data, threadData);
  TestGlider_eqFunction_611(data, threadData);
  TestGlider_eqFunction_610(data, threadData);
  TestGlider_eqFunction_609(data, threadData);
  TestGlider_eqFunction_608(data, threadData);
  TestGlider_eqFunction_607(data, threadData);
  TestGlider_eqFunction_606(data, threadData);
  TestGlider_eqFunction_605(data, threadData);
  TestGlider_eqFunction_604(data, threadData);
  TestGlider_eqFunction_603(data, threadData);
  TestGlider_eqFunction_602(data, threadData);
  TestGlider_eqFunction_601(data, threadData);
  TestGlider_eqFunction_600(data, threadData);
  TestGlider_eqFunction_599(data, threadData);
  TestGlider_eqFunction_598(data, threadData);
  TestGlider_eqFunction_597(data, threadData);
  TestGlider_eqFunction_596(data, threadData);
  TestGlider_eqFunction_595(data, threadData);
  TestGlider_eqFunction_594(data, threadData);
  TestGlider_eqFunction_593(data, threadData);
  TestGlider_eqFunction_592(data, threadData);
  TestGlider_eqFunction_591(data, threadData);
  TestGlider_eqFunction_590(data, threadData);
  TestGlider_eqFunction_589(data, threadData);
  TestGlider_eqFunction_588(data, threadData);
  TestGlider_eqFunction_587(data, threadData);
  TestGlider_eqFunction_586(data, threadData);
  TestGlider_eqFunction_585(data, threadData);
  TestGlider_eqFunction_584(data, threadData);
  TestGlider_eqFunction_583(data, threadData);
  TestGlider_eqFunction_582(data, threadData);
  TestGlider_eqFunction_581(data, threadData);
  TestGlider_eqFunction_580(data, threadData);
  TestGlider_eqFunction_579(data, threadData);
  TestGlider_eqFunction_578(data, threadData);
  TestGlider_eqFunction_577(data, threadData);
  TestGlider_eqFunction_576(data, threadData);
  TestGlider_eqFunction_575(data, threadData);
  TestGlider_eqFunction_574(data, threadData);
  TestGlider_eqFunction_573(data, threadData);
  TestGlider_eqFunction_572(data, threadData);
  TestGlider_eqFunction_571(data, threadData);
  TestGlider_eqFunction_570(data, threadData);
  TestGlider_eqFunction_569(data, threadData);
  TestGlider_eqFunction_568(data, threadData);
  TestGlider_eqFunction_567(data, threadData);
  TestGlider_eqFunction_566(data, threadData);
  TestGlider_eqFunction_565(data, threadData);
  TestGlider_eqFunction_564(data, threadData);
  TestGlider_eqFunction_563(data, threadData);
  TestGlider_eqFunction_562(data, threadData);
  TestGlider_eqFunction_561(data, threadData);
  TestGlider_eqFunction_560(data, threadData);
  TestGlider_eqFunction_559(data, threadData);
  TestGlider_eqFunction_558(data, threadData);
  TestGlider_eqFunction_557(data, threadData);
  TestGlider_eqFunction_556(data, threadData);
  TestGlider_eqFunction_555(data, threadData);
  TestGlider_eqFunction_554(data, threadData);
  TestGlider_eqFunction_553(data, threadData);
  TestGlider_eqFunction_552(data, threadData);
  TestGlider_eqFunction_551(data, threadData);
  TestGlider_eqFunction_550(data, threadData);
  TestGlider_eqFunction_549(data, threadData);
  TestGlider_eqFunction_548(data, threadData);
  TestGlider_eqFunction_547(data, threadData);
  TestGlider_eqFunction_546(data, threadData);
  TestGlider_eqFunction_545(data, threadData);
  TestGlider_eqFunction_544(data, threadData);
  TestGlider_eqFunction_543(data, threadData);
  TestGlider_eqFunction_542(data, threadData);
  TestGlider_eqFunction_541(data, threadData);
  TestGlider_eqFunction_540(data, threadData);
  TestGlider_eqFunction_539(data, threadData);
  TestGlider_eqFunction_538(data, threadData);
  TestGlider_eqFunction_537(data, threadData);
  TestGlider_eqFunction_536(data, threadData);
  TestGlider_eqFunction_535(data, threadData);
  TestGlider_eqFunction_534(data, threadData);
  TestGlider_eqFunction_533(data, threadData);
  TestGlider_eqFunction_532(data, threadData);
  TestGlider_eqFunction_531(data, threadData);
  TestGlider_eqFunction_530(data, threadData);
  TestGlider_eqFunction_529(data, threadData);
  TestGlider_eqFunction_528(data, threadData);
  TestGlider_eqFunction_527(data, threadData);
  TestGlider_eqFunction_526(data, threadData);
  TestGlider_eqFunction_525(data, threadData);
  TestGlider_eqFunction_524(data, threadData);
  TestGlider_eqFunction_523(data, threadData);
  TestGlider_eqFunction_522(data, threadData);
  TestGlider_eqFunction_521(data, threadData);
  TestGlider_eqFunction_520(data, threadData);
  TestGlider_eqFunction_519(data, threadData);
  TestGlider_eqFunction_518(data, threadData);
  TestGlider_eqFunction_517(data, threadData);
  TestGlider_eqFunction_516(data, threadData);
  TestGlider_eqFunction_515(data, threadData);
  TestGlider_eqFunction_514(data, threadData);
  TestGlider_eqFunction_513(data, threadData);
  TestGlider_eqFunction_512(data, threadData);
  TestGlider_eqFunction_511(data, threadData);
  TestGlider_eqFunction_510(data, threadData);
  TestGlider_eqFunction_509(data, threadData);
  TestGlider_eqFunction_508(data, threadData);
  TestGlider_eqFunction_507(data, threadData);
  TestGlider_eqFunction_506(data, threadData);
  TestGlider_eqFunction_505(data, threadData);
  TestGlider_eqFunction_504(data, threadData);
  TestGlider_eqFunction_503(data, threadData);
  TestGlider_eqFunction_502(data, threadData);
  TestGlider_eqFunction_501(data, threadData);
  TestGlider_eqFunction_500(data, threadData);
  TestGlider_eqFunction_499(data, threadData);
  TestGlider_eqFunction_498(data, threadData);
  TestGlider_eqFunction_497(data, threadData);
  TestGlider_eqFunction_496(data, threadData);
  TestGlider_eqFunction_495(data, threadData);
  TestGlider_eqFunction_494(data, threadData);
  TestGlider_eqFunction_493(data, threadData);
  TestGlider_eqFunction_492(data, threadData);
  TestGlider_eqFunction_491(data, threadData);
  TestGlider_eqFunction_490(data, threadData);
  TestGlider_eqFunction_489(data, threadData);
  TestGlider_eqFunction_488(data, threadData);
  TestGlider_eqFunction_487(data, threadData);
  TestGlider_eqFunction_486(data, threadData);
  TestGlider_eqFunction_485(data, threadData);
  TestGlider_eqFunction_484(data, threadData);
  TestGlider_eqFunction_483(data, threadData);
  TestGlider_eqFunction_482(data, threadData);
  TestGlider_eqFunction_481(data, threadData);
  TestGlider_eqFunction_480(data, threadData);
  TestGlider_eqFunction_479(data, threadData);
  TestGlider_eqFunction_478(data, threadData);
  TestGlider_eqFunction_477(data, threadData);
  TestGlider_eqFunction_476(data, threadData);
  TestGlider_eqFunction_475(data, threadData);
  TestGlider_eqFunction_474(data, threadData);
  TestGlider_eqFunction_473(data, threadData);
  TestGlider_eqFunction_472(data, threadData);
  TestGlider_eqFunction_471(data, threadData);
  TestGlider_eqFunction_468(data, threadData);
  TestGlider_eqFunction_467(data, threadData);
  TestGlider_eqFunction_466(data, threadData);
  TestGlider_eqFunction_465(data, threadData);
  TestGlider_eqFunction_464(data, threadData);
  TestGlider_eqFunction_463(data, threadData);
  TestGlider_eqFunction_462(data, threadData);
  TestGlider_eqFunction_461(data, threadData);
  TestGlider_eqFunction_460(data, threadData);
  TestGlider_eqFunction_459(data, threadData);
  TestGlider_eqFunction_458(data, threadData);
  TestGlider_eqFunction_457(data, threadData);
  TestGlider_eqFunction_456(data, threadData);
  TestGlider_eqFunction_455(data, threadData);
  TestGlider_eqFunction_452(data, threadData);
  TestGlider_eqFunction_451(data, threadData);
  TestGlider_eqFunction_450(data, threadData);
  TestGlider_eqFunction_449(data, threadData);
  TestGlider_eqFunction_448(data, threadData);
  TestGlider_eqFunction_447(data, threadData);
  TestGlider_eqFunction_446(data, threadData);
  TestGlider_eqFunction_445(data, threadData);
  TestGlider_eqFunction_444(data, threadData);
  TestGlider_eqFunction_443(data, threadData);
  TestGlider_eqFunction_442(data, threadData);
  TestGlider_eqFunction_441(data, threadData);
  TestGlider_eqFunction_440(data, threadData);
  TestGlider_eqFunction_439(data, threadData);
  TestGlider_eqFunction_438(data, threadData);
  TestGlider_eqFunction_437(data, threadData);
  TestGlider_eqFunction_436(data, threadData);
  TestGlider_eqFunction_435(data, threadData);
  TestGlider_eqFunction_434(data, threadData);
  TestGlider_eqFunction_433(data, threadData);
  TestGlider_eqFunction_432(data, threadData);
  TestGlider_eqFunction_431(data, threadData);
  TestGlider_eqFunction_430(data, threadData);
  TestGlider_eqFunction_429(data, threadData);
  TestGlider_eqFunction_428(data, threadData);
  TestGlider_eqFunction_427(data, threadData);
  TestGlider_eqFunction_426(data, threadData);
  TestGlider_eqFunction_425(data, threadData);
  TestGlider_eqFunction_424(data, threadData);
  TestGlider_eqFunction_423(data, threadData);
  TestGlider_eqFunction_422(data, threadData);
  TestGlider_eqFunction_421(data, threadData);
  TestGlider_eqFunction_420(data, threadData);
  TestGlider_eqFunction_419(data, threadData);
  TestGlider_eqFunction_418(data, threadData);
  TestGlider_eqFunction_417(data, threadData);
  TestGlider_eqFunction_416(data, threadData);
  TestGlider_eqFunction_415(data, threadData);
  TestGlider_eqFunction_414(data, threadData);
  TestGlider_eqFunction_413(data, threadData);
  TestGlider_eqFunction_412(data, threadData);
  TestGlider_eqFunction_411(data, threadData);
  TestGlider_eqFunction_409(data, threadData);
  TestGlider_eqFunction_408(data, threadData);
  TestGlider_eqFunction_407(data, threadData);
  TestGlider_eqFunction_406(data, threadData);
  TestGlider_eqFunction_405(data, threadData);
  TestGlider_eqFunction_404(data, threadData);
  TestGlider_eqFunction_403(data, threadData);
  TestGlider_eqFunction_402(data, threadData);
  TestGlider_eqFunction_401(data, threadData);
  TestGlider_eqFunction_400(data, threadData);
  TestGlider_eqFunction_399(data, threadData);
  TestGlider_eqFunction_398(data, threadData);
  TestGlider_eqFunction_397(data, threadData);
  TestGlider_eqFunction_396(data, threadData);
  TestGlider_eqFunction_395(data, threadData);
  TestGlider_eqFunction_394(data, threadData);
  TestGlider_eqFunction_392(data, threadData);
  TestGlider_eqFunction_390(data, threadData);
  TestGlider_eqFunction_389(data, threadData);
  TestGlider_eqFunction_388(data, threadData);
  TestGlider_eqFunction_387(data, threadData);
  TestGlider_eqFunction_386(data, threadData);
  TestGlider_eqFunction_385(data, threadData);
  TestGlider_eqFunction_384(data, threadData);
  TestGlider_eqFunction_383(data, threadData);
  TestGlider_eqFunction_382(data, threadData);
  TestGlider_eqFunction_381(data, threadData);
  TestGlider_eqFunction_380(data, threadData);
  TestGlider_eqFunction_379(data, threadData);
  TestGlider_eqFunction_378(data, threadData);
  TestGlider_eqFunction_377(data, threadData);
  TestGlider_eqFunction_376(data, threadData);
  TestGlider_eqFunction_375(data, threadData);
  TestGlider_eqFunction_374(data, threadData);
  TestGlider_eqFunction_373(data, threadData);
  TestGlider_eqFunction_372(data, threadData);
  TestGlider_eqFunction_371(data, threadData);
  TestGlider_eqFunction_370(data, threadData);
  TestGlider_eqFunction_369(data, threadData);
  TestGlider_eqFunction_368(data, threadData);
  TestGlider_eqFunction_367(data, threadData);
  TestGlider_eqFunction_366(data, threadData);
  TestGlider_eqFunction_365(data, threadData);
  TestGlider_eqFunction_364(data, threadData);
  TestGlider_eqFunction_363(data, threadData);
  TestGlider_eqFunction_362(data, threadData);
  TestGlider_eqFunction_361(data, threadData);
  TestGlider_eqFunction_360(data, threadData);
  TestGlider_eqFunction_359(data, threadData);
  TestGlider_eqFunction_358(data, threadData);
  TestGlider_eqFunction_357(data, threadData);
  TestGlider_eqFunction_356(data, threadData);
  TestGlider_eqFunction_355(data, threadData);
  TestGlider_eqFunction_354(data, threadData);
  TestGlider_eqFunction_353(data, threadData);
  TestGlider_eqFunction_352(data, threadData);
  TestGlider_eqFunction_351(data, threadData);
  TestGlider_eqFunction_350(data, threadData);
  TestGlider_eqFunction_349(data, threadData);
  TestGlider_eqFunction_348(data, threadData);
  TestGlider_eqFunction_347(data, threadData);
  TestGlider_eqFunction_346(data, threadData);
  TestGlider_eqFunction_345(data, threadData);
  TestGlider_eqFunction_344(data, threadData);
  TestGlider_eqFunction_343(data, threadData);
  TestGlider_eqFunction_342(data, threadData);
  TestGlider_eqFunction_341(data, threadData);
  TestGlider_eqFunction_337(data, threadData);
  TestGlider_eqFunction_336(data, threadData);
  TestGlider_eqFunction_335(data, threadData);
  TestGlider_eqFunction_334(data, threadData);
  TestGlider_eqFunction_333(data, threadData);
  TestGlider_eqFunction_332(data, threadData);
  TestGlider_eqFunction_331(data, threadData);
  TestGlider_eqFunction_330(data, threadData);
  TestGlider_eqFunction_329(data, threadData);
  TestGlider_eqFunction_328(data, threadData);
  TestGlider_eqFunction_327(data, threadData);
  TestGlider_eqFunction_326(data, threadData);
  TestGlider_eqFunction_325(data, threadData);
  TestGlider_eqFunction_324(data, threadData);
  TestGlider_eqFunction_323(data, threadData);
  TestGlider_eqFunction_322(data, threadData);
  TestGlider_eqFunction_321(data, threadData);
  TestGlider_eqFunction_320(data, threadData);
  TestGlider_eqFunction_319(data, threadData);
  TestGlider_eqFunction_318(data, threadData);
  TestGlider_eqFunction_317(data, threadData);
  TestGlider_eqFunction_316(data, threadData);
  TestGlider_eqFunction_315(data, threadData);
  TestGlider_eqFunction_314(data, threadData);
  TestGlider_eqFunction_313(data, threadData);
  TestGlider_eqFunction_312(data, threadData);
  TestGlider_eqFunction_311(data, threadData);
  TestGlider_eqFunction_310(data, threadData);
  TestGlider_eqFunction_309(data, threadData);
  TestGlider_eqFunction_308(data, threadData);
  TestGlider_eqFunction_307(data, threadData);
  TestGlider_eqFunction_306(data, threadData);
  TestGlider_eqFunction_305(data, threadData);
  TestGlider_eqFunction_304(data, threadData);
  TestGlider_eqFunction_303(data, threadData);
  TestGlider_eqFunction_302(data, threadData);
  TestGlider_eqFunction_301(data, threadData);
  TestGlider_eqFunction_300(data, threadData);
  TestGlider_eqFunction_299(data, threadData);
  TestGlider_eqFunction_298(data, threadData);
  TestGlider_eqFunction_297(data, threadData);
  TestGlider_eqFunction_296(data, threadData);
  TestGlider_eqFunction_295(data, threadData);
  TestGlider_eqFunction_294(data, threadData);
  TestGlider_eqFunction_293(data, threadData);
  TestGlider_eqFunction_292(data, threadData);
  TestGlider_eqFunction_291(data, threadData);
  TestGlider_eqFunction_290(data, threadData);
  TestGlider_eqFunction_289(data, threadData);
  TestGlider_eqFunction_288(data, threadData);
  TestGlider_eqFunction_287(data, threadData);
  TestGlider_eqFunction_286(data, threadData);
  TestGlider_eqFunction_285(data, threadData);
  TestGlider_eqFunction_284(data, threadData);
  TestGlider_eqFunction_283(data, threadData);
  TestGlider_eqFunction_282(data, threadData);
  TestGlider_eqFunction_281(data, threadData);
  TestGlider_eqFunction_280(data, threadData);
  TestGlider_eqFunction_279(data, threadData);
  TestGlider_eqFunction_278(data, threadData);
  TestGlider_eqFunction_277(data, threadData);
  TestGlider_eqFunction_276(data, threadData);
  TestGlider_eqFunction_275(data, threadData);
  TestGlider_eqFunction_274(data, threadData);
  TestGlider_eqFunction_273(data, threadData);
  TestGlider_eqFunction_272(data, threadData);
  TestGlider_eqFunction_271(data, threadData);
  TestGlider_eqFunction_270(data, threadData);
  TestGlider_eqFunction_269(data, threadData);
  TestGlider_eqFunction_268(data, threadData);
  TestGlider_eqFunction_267(data, threadData);
  TestGlider_eqFunction_266(data, threadData);
  TestGlider_eqFunction_265(data, threadData);
  TestGlider_eqFunction_264(data, threadData);
  TestGlider_eqFunction_263(data, threadData);
  TestGlider_eqFunction_262(data, threadData);
  TestGlider_eqFunction_261(data, threadData);
  TestGlider_eqFunction_260(data, threadData);
  TestGlider_eqFunction_259(data, threadData);
  TestGlider_eqFunction_258(data, threadData);
  TestGlider_eqFunction_257(data, threadData);
  TestGlider_eqFunction_256(data, threadData);
  TestGlider_eqFunction_255(data, threadData);
  TestGlider_eqFunction_254(data, threadData);
  TestGlider_eqFunction_253(data, threadData);
  TestGlider_eqFunction_252(data, threadData);
  TestGlider_eqFunction_251(data, threadData);
  TestGlider_eqFunction_250(data, threadData);
  TestGlider_eqFunction_249(data, threadData);
  TestGlider_eqFunction_248(data, threadData);
  TestGlider_eqFunction_247(data, threadData);
  TestGlider_eqFunction_246(data, threadData);
  TestGlider_eqFunction_245(data, threadData);
  TestGlider_eqFunction_244(data, threadData);
  TestGlider_eqFunction_243(data, threadData);
  TestGlider_eqFunction_242(data, threadData);
  TestGlider_eqFunction_241(data, threadData);
  TestGlider_eqFunction_240(data, threadData);
  TestGlider_eqFunction_239(data, threadData);
  TestGlider_eqFunction_238(data, threadData);
  TestGlider_eqFunction_237(data, threadData);
  TestGlider_eqFunction_236(data, threadData);
  TestGlider_eqFunction_235(data, threadData);
  TestGlider_eqFunction_234(data, threadData);
  TestGlider_eqFunction_233(data, threadData);
  TestGlider_eqFunction_232(data, threadData);
  TestGlider_eqFunction_231(data, threadData);
  TestGlider_eqFunction_230(data, threadData);
  TestGlider_eqFunction_229(data, threadData);
  TestGlider_eqFunction_228(data, threadData);
  TestGlider_eqFunction_227(data, threadData);
  TestGlider_eqFunction_226(data, threadData);
  TestGlider_eqFunction_225(data, threadData);
  TestGlider_eqFunction_224(data, threadData);
  TestGlider_eqFunction_223(data, threadData);
  TestGlider_eqFunction_222(data, threadData);
  TestGlider_eqFunction_221(data, threadData);
  TestGlider_eqFunction_220(data, threadData);
  TestGlider_eqFunction_219(data, threadData);
  TestGlider_eqFunction_218(data, threadData);
  TestGlider_eqFunction_217(data, threadData);
  TestGlider_eqFunction_216(data, threadData);
  TestGlider_eqFunction_215(data, threadData);
  TestGlider_eqFunction_214(data, threadData);
  TestGlider_eqFunction_213(data, threadData);
  TestGlider_eqFunction_212(data, threadData);
  TestGlider_eqFunction_211(data, threadData);
  TestGlider_eqFunction_210(data, threadData);
  TestGlider_eqFunction_209(data, threadData);
  TestGlider_eqFunction_208(data, threadData);
  TestGlider_eqFunction_207(data, threadData);
  TestGlider_eqFunction_206(data, threadData);
  TestGlider_eqFunction_205(data, threadData);
  TestGlider_eqFunction_204(data, threadData);
  TestGlider_eqFunction_203(data, threadData);
  TestGlider_eqFunction_175(data, threadData);
  TestGlider_eqFunction_174(data, threadData);
  TestGlider_eqFunction_173(data, threadData);
  TestGlider_eqFunction_202(data, threadData);
  TestGlider_eqFunction_171(data, threadData);
  TestGlider_eqFunction_201(data, threadData);
  TestGlider_eqFunction_200(data, threadData);
  TestGlider_eqFunction_199(data, threadData);
  TestGlider_eqFunction_198(data, threadData);
  TestGlider_eqFunction_197(data, threadData);
  TestGlider_eqFunction_196(data, threadData);
  TestGlider_eqFunction_195(data, threadData);
  TestGlider_eqFunction_194(data, threadData);
  TestGlider_eqFunction_193(data, threadData);
  TestGlider_eqFunction_192(data, threadData);
  TestGlider_eqFunction_191(data, threadData);
  TestGlider_eqFunction_190(data, threadData);
  TestGlider_eqFunction_189(data, threadData);
  TestGlider_eqFunction_188(data, threadData);
  TestGlider_eqFunction_187(data, threadData);
  TestGlider_eqFunction_172(data, threadData);
  TestGlider_eqFunction_176(data, threadData);
  TestGlider_eqFunction_170(data, threadData);
  TestGlider_eqFunction_169(data, threadData);
  TestGlider_eqFunction_168(data, threadData);
  TestGlider_eqFunction_167(data, threadData);
  TestGlider_eqFunction_166(data, threadData);
  TestGlider_eqFunction_165(data, threadData);
  TestGlider_eqFunction_164(data, threadData);
  TestGlider_eqFunction_163(data, threadData);
  TestGlider_eqFunction_162(data, threadData);
  TestGlider_eqFunction_161(data, threadData);
  TestGlider_eqFunction_160(data, threadData);
  TestGlider_eqFunction_159(data, threadData);
  TestGlider_eqFunction_158(data, threadData);
  TestGlider_eqFunction_157(data, threadData);
  TestGlider_eqFunction_156(data, threadData);
  TestGlider_eqFunction_155(data, threadData);
  TestGlider_eqFunction_154(data, threadData);
  TestGlider_eqFunction_153(data, threadData);
  TestGlider_eqFunction_152(data, threadData);
  TestGlider_eqFunction_151(data, threadData);
  TestGlider_eqFunction_150(data, threadData);
  TestGlider_eqFunction_149(data, threadData);
  TestGlider_eqFunction_148(data, threadData);
  TestGlider_eqFunction_147(data, threadData);
  TestGlider_eqFunction_146(data, threadData);
  TestGlider_eqFunction_145(data, threadData);
  TestGlider_eqFunction_144(data, threadData);
  TestGlider_eqFunction_143(data, threadData);
  TestGlider_eqFunction_142(data, threadData);
  TestGlider_eqFunction_141(data, threadData);
  TestGlider_eqFunction_140(data, threadData);
  TestGlider_eqFunction_139(data, threadData);
  TestGlider_eqFunction_138(data, threadData);
  TestGlider_eqFunction_137(data, threadData);
  TestGlider_eqFunction_136(data, threadData);
  TestGlider_eqFunction_135(data, threadData);
  TestGlider_eqFunction_134(data, threadData);
  TestGlider_eqFunction_133(data, threadData);
  TestGlider_eqFunction_132(data, threadData);
  TestGlider_eqFunction_131(data, threadData);
  TestGlider_eqFunction_130(data, threadData);
  TestGlider_eqFunction_129(data, threadData);
  TestGlider_eqFunction_128(data, threadData);
  TestGlider_eqFunction_127(data, threadData);
  TestGlider_eqFunction_126(data, threadData);
  TestGlider_eqFunction_125(data, threadData);
  TestGlider_eqFunction_124(data, threadData);
  TestGlider_eqFunction_123(data, threadData);
  TestGlider_eqFunction_122(data, threadData);
  TestGlider_eqFunction_121(data, threadData);
  TestGlider_eqFunction_120(data, threadData);
  TestGlider_eqFunction_119(data, threadData);
  TestGlider_eqFunction_118(data, threadData);
  TestGlider_eqFunction_117(data, threadData);
  TestGlider_eqFunction_116(data, threadData);
  TestGlider_eqFunction_115(data, threadData);
  TestGlider_eqFunction_114(data, threadData);
  TestGlider_eqFunction_113(data, threadData);
  TestGlider_eqFunction_112(data, threadData);
  TestGlider_eqFunction_111(data, threadData);
  TestGlider_eqFunction_110(data, threadData);
  TestGlider_eqFunction_109(data, threadData);
  TestGlider_eqFunction_108(data, threadData);
  TestGlider_eqFunction_107(data, threadData);
  TestGlider_eqFunction_106(data, threadData);
  TestGlider_eqFunction_105(data, threadData);
  TestGlider_eqFunction_104(data, threadData);
  TestGlider_eqFunction_103(data, threadData);
  TestGlider_eqFunction_102(data, threadData);
  TestGlider_eqFunction_101(data, threadData);
  TestGlider_eqFunction_100(data, threadData);
  TestGlider_eqFunction_99(data, threadData);
  TestGlider_eqFunction_98(data, threadData);
  TestGlider_eqFunction_97(data, threadData);
  TestGlider_eqFunction_96(data, threadData);
  TestGlider_eqFunction_95(data, threadData);
  TestGlider_eqFunction_94(data, threadData);
  TestGlider_eqFunction_93(data, threadData);
  TestGlider_eqFunction_92(data, threadData);
  TestGlider_eqFunction_91(data, threadData);
  TestGlider_eqFunction_90(data, threadData);
  TestGlider_eqFunction_89(data, threadData);
  TestGlider_eqFunction_88(data, threadData);
  TestGlider_eqFunction_87(data, threadData);
  TestGlider_eqFunction_86(data, threadData);
  TestGlider_eqFunction_85(data, threadData);
  TestGlider_eqFunction_84(data, threadData);
  TestGlider_eqFunction_83(data, threadData);
  TestGlider_eqFunction_82(data, threadData);
  TestGlider_eqFunction_81(data, threadData);
  TestGlider_eqFunction_80(data, threadData);
  TestGlider_eqFunction_79(data, threadData);
  TestGlider_eqFunction_78(data, threadData);
  TestGlider_eqFunction_77(data, threadData);
  TestGlider_eqFunction_76(data, threadData);
  TestGlider_eqFunction_75(data, threadData);
  TestGlider_eqFunction_74(data, threadData);
  TestGlider_eqFunction_73(data, threadData);
  TestGlider_eqFunction_72(data, threadData);
  TestGlider_eqFunction_71(data, threadData);
  TestGlider_eqFunction_70(data, threadData);
  TestGlider_eqFunction_69(data, threadData);
  TestGlider_eqFunction_68(data, threadData);
  TestGlider_eqFunction_67(data, threadData);
  TestGlider_eqFunction_66(data, threadData);
  TestGlider_eqFunction_65(data, threadData);
  TestGlider_eqFunction_64(data, threadData);
  TestGlider_eqFunction_63(data, threadData);
  TestGlider_eqFunction_62(data, threadData);
  TestGlider_eqFunction_61(data, threadData);
  TestGlider_eqFunction_60(data, threadData);
  TestGlider_eqFunction_59(data, threadData);
  TestGlider_eqFunction_58(data, threadData);
  TestGlider_eqFunction_57(data, threadData);
  TestGlider_eqFunction_56(data, threadData);
  TestGlider_eqFunction_55(data, threadData);
  TestGlider_eqFunction_54(data, threadData);
  TestGlider_eqFunction_53(data, threadData);
  TestGlider_eqFunction_52(data, threadData);
  TestGlider_eqFunction_51(data, threadData);
  TestGlider_eqFunction_50(data, threadData);
  TestGlider_eqFunction_49(data, threadData);
  TestGlider_eqFunction_48(data, threadData);
  TestGlider_eqFunction_47(data, threadData);
  TestGlider_eqFunction_46(data, threadData);
  TestGlider_eqFunction_45(data, threadData);
  TestGlider_eqFunction_44(data, threadData);
  TestGlider_eqFunction_43(data, threadData);
  TestGlider_eqFunction_42(data, threadData);
  TestGlider_eqFunction_41(data, threadData);
  TestGlider_eqFunction_40(data, threadData);
  TestGlider_eqFunction_39(data, threadData);
  TestGlider_eqFunction_38(data, threadData);
  TestGlider_eqFunction_37(data, threadData);
  TestGlider_eqFunction_36(data, threadData);
  TestGlider_eqFunction_35(data, threadData);
  TestGlider_eqFunction_34(data, threadData);
  TestGlider_eqFunction_33(data, threadData);
  TestGlider_eqFunction_32(data, threadData);
  TestGlider_eqFunction_31(data, threadData);
  TestGlider_eqFunction_30(data, threadData);
  TestGlider_eqFunction_29(data, threadData);
  TestGlider_eqFunction_28(data, threadData);
  TestGlider_eqFunction_27(data, threadData);
  TestGlider_eqFunction_26(data, threadData);
  TestGlider_eqFunction_25(data, threadData);
  TestGlider_eqFunction_24(data, threadData);
  TestGlider_eqFunction_23(data, threadData);
  TestGlider_eqFunction_22(data, threadData);
  TestGlider_eqFunction_21(data, threadData);
  TestGlider_eqFunction_20(data, threadData);
  TestGlider_eqFunction_19(data, threadData);
  TestGlider_eqFunction_18(data, threadData);
  TestGlider_eqFunction_17(data, threadData);
  TestGlider_eqFunction_16(data, threadData);
  TestGlider_eqFunction_15(data, threadData);
  TestGlider_eqFunction_14(data, threadData);
  TestGlider_eqFunction_13(data, threadData);
  TestGlider_eqFunction_12(data, threadData);
  TestGlider_eqFunction_11(data, threadData);
  TestGlider_eqFunction_10(data, threadData);
  TestGlider_eqFunction_9(data, threadData);
  TestGlider_eqFunction_8(data, threadData);
  TestGlider_eqFunction_7(data, threadData);
  TestGlider_eqFunction_6(data, threadData);
  TestGlider_eqFunction_5(data, threadData);
  TestGlider_eqFunction_4(data, threadData);
  TestGlider_eqFunction_2(data, threadData);
  TestGlider_eqFunction_7342(data, threadData);
  TestGlider_eqFunction_7343(data, threadData);
  TestGlider_eqFunction_7344(data, threadData);
  TestGlider_eqFunction_7345(data, threadData);
  TestGlider_eqFunction_7346(data, threadData);
  TestGlider_eqFunction_7347(data, threadData);
  TestGlider_eqFunction_7348(data, threadData);
  TestGlider_eqFunction_7349(data, threadData);
  TestGlider_eqFunction_7350(data, threadData);
  TestGlider_eqFunction_7351(data, threadData);
  TestGlider_eqFunction_7352(data, threadData);
  TestGlider_eqFunction_7353(data, threadData);
  TestGlider_eqFunction_7354(data, threadData);
  TestGlider_eqFunction_7355(data, threadData);
  TestGlider_eqFunction_7356(data, threadData);
  TestGlider_eqFunction_7357(data, threadData);
  TestGlider_eqFunction_7358(data, threadData);
  TestGlider_eqFunction_7359(data, threadData);
  TestGlider_eqFunction_7360(data, threadData);
  TestGlider_eqFunction_7361(data, threadData);
  TestGlider_eqFunction_7362(data, threadData);
  TestGlider_eqFunction_7363(data, threadData);
  TestGlider_eqFunction_7364(data, threadData);
  TestGlider_eqFunction_7365(data, threadData);
  TestGlider_eqFunction_7366(data, threadData);
  TestGlider_eqFunction_7367(data, threadData);
  TestGlider_eqFunction_7368(data, threadData);
  TestGlider_eqFunction_7369(data, threadData);
  TestGlider_eqFunction_7370(data, threadData);
  TestGlider_eqFunction_7371(data, threadData);
  TestGlider_eqFunction_7372(data, threadData);
  TestGlider_eqFunction_7373(data, threadData);
  TestGlider_eqFunction_7374(data, threadData);
  TestGlider_eqFunction_7375(data, threadData);
  TestGlider_eqFunction_7376(data, threadData);
  TestGlider_eqFunction_7377(data, threadData);
  TestGlider_eqFunction_7378(data, threadData);
  TestGlider_eqFunction_7379(data, threadData);
  TestGlider_eqFunction_7380(data, threadData);
  TestGlider_eqFunction_7381(data, threadData);
  TestGlider_eqFunction_7382(data, threadData);
  TestGlider_eqFunction_7383(data, threadData);
  TestGlider_eqFunction_7384(data, threadData);
  TestGlider_eqFunction_7385(data, threadData);
  TestGlider_eqFunction_7386(data, threadData);
  TestGlider_eqFunction_7387(data, threadData);
  TestGlider_eqFunction_7388(data, threadData);
  TestGlider_eqFunction_7389(data, threadData);
  TestGlider_eqFunction_7390(data, threadData);
  TestGlider_eqFunction_7391(data, threadData);
  TestGlider_eqFunction_7392(data, threadData);
  TestGlider_eqFunction_7393(data, threadData);
  TestGlider_eqFunction_7394(data, threadData);
  TestGlider_eqFunction_7395(data, threadData);
  TestGlider_eqFunction_7396(data, threadData);
  TestGlider_eqFunction_7397(data, threadData);
  TestGlider_eqFunction_7398(data, threadData);
  TestGlider_eqFunction_7399(data, threadData);
  TestGlider_eqFunction_7400(data, threadData);
  TestGlider_eqFunction_7401(data, threadData);
  TestGlider_eqFunction_7402(data, threadData);
  TestGlider_eqFunction_7403(data, threadData);
  TestGlider_eqFunction_7404(data, threadData);
  TestGlider_eqFunction_7405(data, threadData);
  TestGlider_eqFunction_7406(data, threadData);
  TestGlider_eqFunction_7407(data, threadData);
  TestGlider_eqFunction_7408(data, threadData);
  TestGlider_eqFunction_7409(data, threadData);
  TestGlider_eqFunction_7410(data, threadData);
  TestGlider_eqFunction_7411(data, threadData);
  TestGlider_eqFunction_7412(data, threadData);
  TestGlider_eqFunction_7413(data, threadData);
  TestGlider_eqFunction_7414(data, threadData);
  TestGlider_eqFunction_7415(data, threadData);
  TestGlider_eqFunction_7416(data, threadData);
  TestGlider_eqFunction_7417(data, threadData);
  TestGlider_eqFunction_7418(data, threadData);
  TestGlider_eqFunction_7419(data, threadData);
  TestGlider_eqFunction_7420(data, threadData);
  TestGlider_eqFunction_7421(data, threadData);
  TestGlider_eqFunction_7422(data, threadData);
  TestGlider_eqFunction_7423(data, threadData);
  TestGlider_eqFunction_7424(data, threadData);
  TestGlider_eqFunction_7425(data, threadData);
  TestGlider_eqFunction_7426(data, threadData);
  TestGlider_eqFunction_7427(data, threadData);
  TestGlider_eqFunction_7428(data, threadData);
  TestGlider_eqFunction_7429(data, threadData);
  TestGlider_eqFunction_7430(data, threadData);
  TestGlider_eqFunction_7431(data, threadData);
  TestGlider_eqFunction_7432(data, threadData);
  TestGlider_eqFunction_7433(data, threadData);
  TestGlider_eqFunction_7434(data, threadData);
  TestGlider_eqFunction_7435(data, threadData);
  TestGlider_eqFunction_7436(data, threadData);
  TestGlider_eqFunction_7437(data, threadData);
  TestGlider_eqFunction_7438(data, threadData);
  TestGlider_eqFunction_7439(data, threadData);
  TestGlider_eqFunction_7440(data, threadData);
  TestGlider_eqFunction_7441(data, threadData);
  TestGlider_eqFunction_7442(data, threadData);
  TestGlider_eqFunction_7443(data, threadData);
  TestGlider_eqFunction_7444(data, threadData);
  TestGlider_eqFunction_7445(data, threadData);
  TestGlider_eqFunction_7446(data, threadData);
  TestGlider_eqFunction_7447(data, threadData);
  TestGlider_eqFunction_7448(data, threadData);
  TestGlider_eqFunction_7449(data, threadData);
  TestGlider_eqFunction_7450(data, threadData);
  TestGlider_eqFunction_7451(data, threadData);
  TestGlider_eqFunction_7452(data, threadData);
  TestGlider_eqFunction_7453(data, threadData);
  TestGlider_eqFunction_7454(data, threadData);
  TestGlider_eqFunction_7455(data, threadData);
  TestGlider_eqFunction_7456(data, threadData);
  TestGlider_eqFunction_7457(data, threadData);
  TestGlider_eqFunction_7458(data, threadData);
  TestGlider_eqFunction_7459(data, threadData);
  TestGlider_eqFunction_7460(data, threadData);
  TestGlider_eqFunction_7461(data, threadData);
  TestGlider_eqFunction_7462(data, threadData);
  TestGlider_eqFunction_7463(data, threadData);
  TestGlider_eqFunction_7464(data, threadData);
  TestGlider_eqFunction_7465(data, threadData);
  TestGlider_eqFunction_7466(data, threadData);
  TestGlider_eqFunction_7467(data, threadData);
  TestGlider_eqFunction_7468(data, threadData);
  TestGlider_eqFunction_7469(data, threadData);
  TestGlider_eqFunction_7470(data, threadData);
  TestGlider_eqFunction_7471(data, threadData);
  TestGlider_eqFunction_7472(data, threadData);
  TestGlider_eqFunction_7473(data, threadData);
  TestGlider_eqFunction_7474(data, threadData);
  TestGlider_eqFunction_7475(data, threadData);
  TestGlider_eqFunction_7476(data, threadData);
  TestGlider_eqFunction_7477(data, threadData);
  TestGlider_eqFunction_7478(data, threadData);
  TestGlider_eqFunction_7479(data, threadData);
  TestGlider_eqFunction_7480(data, threadData);
  TestGlider_eqFunction_7481(data, threadData);
  TestGlider_eqFunction_7482(data, threadData);
  TestGlider_eqFunction_7483(data, threadData);
  TestGlider_eqFunction_7484(data, threadData);
  TestGlider_eqFunction_7485(data, threadData);
  TestGlider_eqFunction_7486(data, threadData);
  TestGlider_eqFunction_7487(data, threadData);
  TestGlider_eqFunction_7488(data, threadData);
  TestGlider_eqFunction_7489(data, threadData);
  TestGlider_eqFunction_7490(data, threadData);
  TestGlider_eqFunction_7491(data, threadData);
  TestGlider_eqFunction_7492(data, threadData);
  TestGlider_eqFunction_7493(data, threadData);
  TestGlider_eqFunction_7494(data, threadData);
  TestGlider_eqFunction_7495(data, threadData);
  TestGlider_eqFunction_7496(data, threadData);
  TestGlider_eqFunction_7497(data, threadData);
  TestGlider_eqFunction_7498(data, threadData);
  TestGlider_eqFunction_7499(data, threadData);
  TestGlider_eqFunction_7500(data, threadData);
  TestGlider_eqFunction_7501(data, threadData);
  TestGlider_eqFunction_7502(data, threadData);
  TestGlider_eqFunction_7503(data, threadData);
  TestGlider_eqFunction_7504(data, threadData);
  TestGlider_eqFunction_7505(data, threadData);
  TestGlider_eqFunction_7506(data, threadData);
  TestGlider_eqFunction_7507(data, threadData);
  TestGlider_eqFunction_7508(data, threadData);
  TestGlider_eqFunction_7509(data, threadData);
  TestGlider_eqFunction_7510(data, threadData);
  TestGlider_eqFunction_7511(data, threadData);
  TestGlider_eqFunction_7512(data, threadData);
  TestGlider_eqFunction_7513(data, threadData);
  TestGlider_eqFunction_7514(data, threadData);
  TestGlider_eqFunction_7515(data, threadData);
  TestGlider_eqFunction_7516(data, threadData);
  TestGlider_eqFunction_7517(data, threadData);
  TestGlider_eqFunction_7518(data, threadData);
  TestGlider_eqFunction_7519(data, threadData);
  TestGlider_eqFunction_7520(data, threadData);
  TestGlider_eqFunction_7521(data, threadData);
  TestGlider_eqFunction_7522(data, threadData);
  TestGlider_eqFunction_7523(data, threadData);
  TestGlider_eqFunction_7524(data, threadData);
  TestGlider_eqFunction_7525(data, threadData);
  TestGlider_eqFunction_7526(data, threadData);
  TestGlider_eqFunction_7527(data, threadData);
  TestGlider_eqFunction_7528(data, threadData);
  TestGlider_eqFunction_7529(data, threadData);
  TestGlider_eqFunction_7530(data, threadData);
  TestGlider_eqFunction_7531(data, threadData);
  TestGlider_eqFunction_7532(data, threadData);
  TestGlider_eqFunction_7533(data, threadData);
  TestGlider_eqFunction_7534(data, threadData);
  TestGlider_eqFunction_7535(data, threadData);
  TestGlider_eqFunction_7536(data, threadData);
  TestGlider_eqFunction_7537(data, threadData);
  TestGlider_eqFunction_7538(data, threadData);
  TestGlider_eqFunction_7539(data, threadData);
  TestGlider_eqFunction_7540(data, threadData);
  TestGlider_eqFunction_7541(data, threadData);
  TestGlider_eqFunction_7542(data, threadData);
  TestGlider_eqFunction_7543(data, threadData);
  TestGlider_eqFunction_7544(data, threadData);
  TestGlider_eqFunction_7545(data, threadData);
  TestGlider_eqFunction_7546(data, threadData);
  TestGlider_eqFunction_7547(data, threadData);
  TestGlider_eqFunction_7548(data, threadData);
  TestGlider_eqFunction_7549(data, threadData);
  TestGlider_eqFunction_7550(data, threadData);
  TestGlider_eqFunction_7551(data, threadData);
  TestGlider_eqFunction_7552(data, threadData);
  TRACE_POP
}
#if defined(__cplusplus)
}
#endif